<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://beancount.github.io/docs/api_reference/beancount.parser.html" rel="canonical"/>
<link href="../img/favicon.ico" rel="shortcut icon"/>
<title>beancount.parser - Beancount Documentation</title>
<link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet">
<link href="../css/theme.css" rel="stylesheet">
<link href="../css/theme_extra.css" rel="stylesheet"/>
<link href="../css/custom.css" rel="stylesheet"/>
<script>
    // Current page data
    var mkdocs_page_name = "beancount.parser";
    var mkdocs_page_input_path = "api_reference/beancount.parser.md";
    var mkdocs_page_url = "/docs/api_reference/beancount.parser.html";
  </script>
<script defer="" src="../js/jquery-2.1.1.min.js"></script>
<script defer="" src="../js/modernizr-2.8.3.min.js"></script>
</link></link></head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href=".."> Beancount Documentation</a>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Index</a>
</li>
</ul>
<p class="caption"><span class="caption-text">Outline</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#">Documentation for Users</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../01_command_line_accounting_in_context.html">Command Line Accounting in Context</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../02_the_double_entry_counting_method.html">The Double Entry Counting Method</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../03_installing_beancount.html">Installing Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../04_running_beancount_and_generating_reports.html">Running Beancount and Generating Reports</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../05_getting_started_with_beancount.html">Getting Started with Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../06_beancount_language_syntax.html">Beancount Language Syntax</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../07_beancount_options_reference.html">Beancount Options Reference</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../08_precision_tolerances.html">Precision Tolerances</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../09_beancount_query_language.html">Beancount Query Language</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../10_beancount_cheat_sheet.html">Beancount Cheat Sheet</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../11_how_inventories_work.html">How Inventories Work</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../12_exporting_your_portfolio.html">Exporting Your Portfolio</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../13_tutorial_example.html">Tutorial &amp; Example</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../14_beancount_history_and_credits.html">Beancount History and Credits</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../15_a_comparison_of_beancount_and_ledger_hledger.html">A Comparison of Beancount and Ledger Hledger</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../16_fetching_prices_in_beancount.html">Fetching Prices in Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../17_importing_external_data.html">Importing External Data</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#">Cookbooks &amp; Examples</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../18_command_line_accounting_cookbook.html">Command Line Accounting Cookbook</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../19_trading_with_beancount.html">Trading with Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../20_stock_vesting_in_beancount.html">Stock Vesting in Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../21_sharing_expenses_with_beancount.html">Sharing Expenses with Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../22_how_we_share_expenses.html">How We Share Expenses</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#">Documentation for Developers</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../23_beancount_scripting_plugins.html">Beancount Scripting Plugins</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../24_beancount_design_doc.html">Beancount Design Doc</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../25_ledgerhub_design_doc.html">Ledgerhub Design Doc</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../26_external_contributions.html">External Contributions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#">Enhancement Proposals &amp; Discussions</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../27_a_proposal_for_an_improvement_on_inventory_booking.html">A Proposal for an Improvement on Inventory Booking</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../28_settlement_dates_in_beancount.html">Settlement Dates in Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../29_balance_assertions_in_beancount.html">Balance Assertions in Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../30_fund_accounting_with_beancount.html">Fund Accounting with Beancount</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../31_rounding_precision_in_beancount.html">Rounding Precision in Beancount</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">beancount</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.core.html">beancount.core</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.ingest.html">beancount.ingest</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.loader.html">beancount.loader</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.ops.html">beancount.ops</a>
</li>
<li class="toctree-l1 current"><a class="reference internal current" href="beancount.parser.html">beancount.parser</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser">beancount.parser</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking">booking</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.BookingError">BookingError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.book">book()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.validate_inventory_booking">validate_inventory_booking()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.validate_missing_eliminated">validate_missing_eliminated()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_full">booking_full</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError">CategorizationError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError">InterpolationError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.MissingType">MissingType</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError">ReductionError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.Refer">Refer</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError">SelfReduxError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.book">book()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.book_reductions">book_reductions()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.categorize_by_currency">categorize_by_currency()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.compute_cost_number">compute_cost_number()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.convert_costspec_to_cost">convert_costspec_to_cost()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.get_bucket_currency">get_bucket_currency()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.has_self_reduction">has_self_reduction()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.interpolate_group">interpolate_group()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.replace_currencies">replace_currencies()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.unique_label">unique_label()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_full_test">booking_full_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.TestBookAugmentations">TestBookAugmentations</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.TestCategorizeCurrencyGroup">TestCategorizeCurrencyGroup</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.TestInterpolateCurrencyGroup">TestInterpolateCurrencyGroup</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.TestReplaceCurrenciesInGroup">TestReplaceCurrenciesInGroup</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.book_test">book_test()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.find_first_with_tag">find_first_with_tag()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.indexes">indexes()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full_test.normalize_postings">normalize_postings()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_method">booking_method</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError">AmbiguousMatchError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_AVERAGE">booking_method_AVERAGE()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_FIFO">booking_method_FIFO()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_LIFO">booking_method_LIFO()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_NONE">booking_method_NONE()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_STRICT">booking_method_STRICT()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.handle_ambiguous_matches">handle_ambiguous_matches()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_method_test">booking_method_test</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_test">booking_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_test.BookingTestError">BookingTestError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_test.BookingTestError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_test.BookingTestError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_test.BookingTestError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_test.TestBookingValidation">TestBookingValidation</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_test.TestBookingValidation.setUp">setUp()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_test.convert_lot_specs_to_lots">convert_lot_specs_to_lots()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_test.convert_spec_to_cost">convert_spec_to_cost()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.cmptest">cmptest</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.TestError">TestError</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.assertEqualEntries">assertEqualEntries()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.assertExcludesEntries">assertExcludesEntries()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.assertIncludesEntries">assertIncludesEntries()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.read_string_or_entries">read_string_or_entries()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.cmptest_test">cmptest_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest_test.TestTestCase">TestTestCase</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.cmptest_test.TestTestCase.setUp">setUp()</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.grammar">grammar</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.Builder">Builder</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.amount">amount()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.balance">balance()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.build_grammar_error">build_grammar_error()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.close">close()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.commodity">commodity()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.compound_amount">compound_amount()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.cost_merge">cost_merge()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.cost_spec">cost_spec()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.custom">custom()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.custom_value">custom_value()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.dcupdate">dcupdate()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.document">document()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.event">event()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.finalize">finalize()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.finalize_tags_links">finalize_tags_links()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_entries">get_entries()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_invalid_account">get_invalid_account()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_long_string_maxlines">get_long_string_maxlines()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_options">get_options()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.handle_list">handle_list()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.include">include()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.key_value">key_value()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.note">note()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.open">open()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.option">option()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pad">pad()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pipe_deprecated_error">pipe_deprecated_error()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.plugin">plugin()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.popmeta">popmeta()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.poptag">poptag()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.posting">posting()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.price">price()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pushmeta">pushmeta()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pushtag">pushtag()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.query">query()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.store_result">store_result()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_LINK">tag_link_LINK()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_new">tag_link_new()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_STRING">tag_link_STRING()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_TAG">tag_link_TAG()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.transaction">transaction()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.unpack_txn_strings">unpack_txn_strings()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount">CompoundAmount</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError">DeprecatedError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.KeyValue">KeyValue</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ParserError">ParserError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError">ParserSyntaxError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks">TagsLinks</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ValueType">ValueType</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.valid_account_regexp">valid_account_regexp()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.grammar_test">grammar_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestLexerAndParserErrors">TestLexerAndParserErrors</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestLineNumbers">TestLineNumbers</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestMetaData">TestMetaData</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar_test.TestMetaData.strip_meta">strip_meta()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestParserComplete">TestParserComplete</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestParserEntryTypes">TestParserEntryTypes</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestSyntaxErrors">TestSyntaxErrors</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.TestUglyBugs">TestUglyBugs</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.check_list">check_list()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar_test.raise_exception">raise_exception()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.hashsrc">hashsrc</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.hashsrc.check_parser_source_files">check_parser_source_files()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.hashsrc.hash_parser_source_files">hash_parser_source_files()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.lexer">lexer</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder">LexBuilder</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.ACCOUNT">ACCOUNT()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.build_lexer_error">build_lexer_error()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.CURRENCY">CURRENCY()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.DATE">DATE()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.get_invalid_account">get_invalid_account()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.KEY">KEY()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.LINK">LINK()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.NUMBER">NUMBER()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.STRING">STRING()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.TAG">TAG()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.LexerError">LexerError</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.lex_iter">lex_iter()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.lex_iter_string">lex_iter_string()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.lexer_test">lexer_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer_test.TestLexer">TestLexer</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer_test.TestLexerErrors">TestLexerErrors</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer_test.lex_tokens">lex_tokens()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer_test.print_tokens">print_tokens()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.options">options</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.OptDesc">OptDesc</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.OptGroup">OptGroup</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__getnewargs__">__getnewargs__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__new__">__new__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__repr__">__repr__()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_account_types">get_account_types()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_current_accounts">get_current_accounts()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_previous_accounts">get_previous_accounts()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.list_options">list_options()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.Opt">Opt()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_booking_method">options_validate_booking_method()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_boolean">options_validate_boolean()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_plugin">options_validate_plugin()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_processing_mode">options_validate_processing_mode()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_tolerance">options_validate_tolerance()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_tolerance_map">options_validate_tolerance_map()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.options_test">options_test</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.parser">parser</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.is_entry_incomplete">is_entry_incomplete()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.is_posting_incomplete">is_posting_incomplete()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_doc">parse_doc()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_file">parse_file()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_many">parse_many()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_one">parse_one()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_string">parse_string()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.parser_test">parser_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser_test.TestParserInputs">TestParserInputs</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.printer">printer</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter">EntryPrinter</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.__call__">__call__()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.render_posting_strings">render_posting_strings()</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.write_metadata">write_metadata()</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.align_position_strings">align_position_strings()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.format_entry">format_entry()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.format_error">format_error()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_entries">print_entries()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_entry">print_entry()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_error">print_error()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_errors">print_errors()</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.render_source">render_source()</a>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#beancount.parser.printer_test">printer_test</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer_test.characterize_spaces">characterize_spaces()</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.plugins.html">beancount.plugins</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.prices.html">beancount.prices</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.query.html">beancount.query</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.reports.html">beancount.reports</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.scripts.html">beancount.scripts</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.utils.html">beancount.utils</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="beancount.web.html">beancount.web</a>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="..">Beancount Documentation</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="..">Docs</a> »</li>
<li>API reference »</li>
<li>beancount.parser</li>
<li class="wy-breadcrumbs-aside">
<a class="icon icon-github" href="https://github.com/beancount/docs/edit/master/docs/api_reference/beancount.parser.md"> Edit on GitHub</a>
</li>
</ul>
<hr/>
</div>
<div role="main">
<div class="section">
<h1 id="beancountparser">beancount.parser<a class="headerlink" href="#beancountparser" title="Permanent link"></a></h1>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" href="#beancount.parser" id="beancount.parser" style="visibility: hidden; width: 0; height: 0;">
<a class="headerlink" href="#beancount.parser" title="Permanent link"></a></h2>
<div class="doc doc-contents first">
<p>Parser module for beancount input files.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking">
<code>booking</code>
<a class="headerlink" href="#beancount.parser.booking" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Algorithms for 'booking' inventory, that is, the process of finding a
matching lot when reducing the content of an inventory.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking.BookingError">
<code>BookingError</code>
<a class="headerlink" href="#beancount.parser.booking.BookingError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>BookingError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking.BookingError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking.BookingError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking.BookingError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking.BookingError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of BookingError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking.BookingError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking.BookingError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking.book">
<code class="highlight language-python">
book
(incomplete_entries, options_map)

        </code>
<a class="headerlink" href="#beancount.parser.booking.book" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Book inventory lots and complete all positions with incomplete numbers.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>incomplete_entries</code></td>
<td><code></code></td>
<td>
<p>A list of directives, with some postings possibly left
with incomplete amounts as produced by the parser.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>options_map</code></td>
<td><code></code></td>
<td>
<p>An options dict as produced by the parser.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A pair of
  entries</code></td>
<td>
<p>A list of completed entries with all their postings completed.
  errors: New errors produced during interpolation.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def book(incomplete_entries, options_map):
    """Book inventory lots and complete all positions with incomplete numbers.

    Args:
      incomplete_entries: A list of directives, with some postings possibly left
        with incomplete amounts as produced by the parser.
      options_map: An options dict as produced by the parser.
    Returns:
      A pair of
        entries: A list of completed entries with all their postings completed.
        errors: New errors produced during interpolation.
    """
    # Get the list of booking methods for each account.
    booking_methods = collections.defaultdict(lambda: options_map["booking_method"])
    for entry in incomplete_entries:
        if isinstance(entry, data.Open) and entry.booking:
            booking_methods[entry.account] = entry.booking

    # Do the booking here!
    entries, booking_errors = booking_full.book(incomplete_entries, options_map,
                                                booking_methods)

    # Check for MISSING elements remaining.
    missing_errors = validate_missing_eliminated(entries, options_map)

    return entries, (booking_errors + missing_errors)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking.validate_inventory_booking">
<code class="highlight language-python">
validate_inventory_booking
(entries, unused_options_map, booking_methods)

        </code>
<a class="headerlink" href="#beancount.parser.booking.validate_inventory_booking" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate that no position at cost is allowed to go negative.</p>
<p>This routine checks that when a posting reduces a position, existing or not,
that the subsequent inventory does not result in a position with a negative
number of units. A negative number of units would only be required for short
trades of trading spreads on futures, and right now this is not supported.
It would not be difficult to support this, however, but we want to be strict
about it, because being pedantic about this is otherwise a great way to
detect user data entry mistakes.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A list of directives.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>unused_options_map</code></td>
<td><code></code></td>
<td>
<p>An options map.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>booking_methods</code></td>
<td><code></code></td>
<td>
<p>A mapping of account name to booking method, accumulated
in the main loop.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of errors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def validate_inventory_booking(entries, unused_options_map, booking_methods):
    """Validate that no position at cost is allowed to go negative.

    This routine checks that when a posting reduces a position, existing or not,
    that the subsequent inventory does not result in a position with a negative
    number of units. A negative number of units would only be required for short
    trades of trading spreads on futures, and right now this is not supported.
    It would not be difficult to support this, however, but we want to be strict
    about it, because being pedantic about this is otherwise a great way to
    detect user data entry mistakes.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
      booking_methods: A mapping of account name to booking method, accumulated
        in the main loop.
    Returns:
      A list of errors.

    """
    errors = []
    balances = collections.defaultdict(inventory.Inventory)
    for entry in entries:
        if isinstance(entry, data.Transaction):
            for posting in entry.postings:
                # Update the balance of each posting on its respective account
                # without allowing booking to a negative position, and if an error
                # is encountered, catch it and return it.
                running_balance = balances[posting.account]
                position_, _ = running_balance.add_position(posting)

                # Skip this check if the booking method is set to ignore it.
                if booking_methods.get(posting.account, None) == data.Booking.NONE:
                    continue

                # Check if the resulting inventory is mixed, which is not
                # allowed under the STRICT method.
                if running_balance.is_mixed():
                    errors.append(
                        BookingError(
                            entry.meta,
                            ("Reducing position results in inventory with positive "
                             "and negative lots: {}").format(position_),
                            entry))

    return errors
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking.validate_missing_eliminated">
<code class="highlight language-python">
validate_missing_eliminated
(entries, unused_options_map)

        </code>
<a class="headerlink" href="#beancount.parser.booking.validate_missing_eliminated" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate that all the missing bits of postings have been eliminated.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A list of directives.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>unused_options_map</code></td>
<td><code></code></td>
<td>
<p>An options map.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of errors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def validate_missing_eliminated(entries, unused_options_map):
    """Validate that all the missing bits of postings have been eliminated.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of errors.
    """
    errors = []
    for entry in entries:
        if isinstance(entry, data.Transaction):
            for posting in entry.postings:
                units = posting.units
                cost = posting.cost
                if (MISSING in (units.number, units.currency) or
                    cost is not None and MISSING in (cost.number, cost.currency,
                                                     cost.date, cost.label)):
                    errors.append(
                        BookingError(entry.meta,
                                     "Transaction has incomplete elements",
                                     entry))
                    break
    return errors
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking_full">
<code>booking_full</code>
<a class="headerlink" href="#beancount.parser.booking_full" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Full (new) booking implementation.</p>
<p>Problem description:</p>
<p>Interpolation and booking feed on each other, that is, numbers filled in from
interpolation might affect the booking process, and numbers derived from the
booking process may help carry out interpolation that would otherwise be
under-defined. Here's an example of interpolation helping the booking process:</p>
<p>Assume the ante-inventory of Assets:Investments contains two lots of shares of
HOOL, one at 100.00 USD and the other at 101.00 USD and apply this transaction:</p>
<pre><code>2015-09-30 *
  Assets:Investments   -10 HOOL {USD}
  Assets:Cash               1000 USD
  Income:Gains              -200 USD
</code></pre>
<p>Interpolation is unambiguously able to back out a cost of 100 USD / HOOL, which
would then result in an unambiguous booking result.</p>
<p>On the other hand, consider this transaction:</p>
<pre><code>2015-09-30 *
  Assets:Investments    -10 HOOL {USD}
  Assets:Cash               1000 USD
  Income:Gains
</code></pre>
<p>Now the interpolation cannot succeed. If the Assets:Investments account is
configured to use the FIFO method, the 10 oldest shares would be selected for
the cost, and we could then interpolate the capital gains correctly.</p>
<p>First observation: The second case is much more frequent than the first, and the
first is easily resolved manually by requiring a particular cost be specified.
Moreover, in many cases there isn't just a single lot of shares to be reduced
from and figuring out the correct set of shares given a target cost is an
underspecified problem.</p>
<p>Second observation: Booking can only be achieved for inventory reductions, not
for augmentations. Therefore, we should carry out booking on inventory
reductions and fail early if reduction is undefined there, and leave inventory
augmentations with missing numbers undefined, so that interpolation can fill
them in at a later stage.</p>
<p>Note that one case we'd like to but may not be able to handle is of a reduction
with interpolated price, like this:</p>
<pre><code>2015-09-30 *
  Assets:Investments        -10 HOOL {100.00 # USD}
  Expenses:Commission      9.95 USD
  Assets:Cash            990.05 USD
</code></pre>
<p>Therefore we choose to</p>
<p>1) Carry out booking first, on inventory reductions only, and leave inventory
   augmentations as they are, possibly undefined. The 'cost' attributed of
   booked postings are converted from CostSpec to Cost. Augmented postings with
   missing amounts are left as CostSpec instances in order to allow for
   interpolation of total vs. per-unit amount.</p>
<p>2) Compute interpolations on the resulting postings. Undefined costs for
   inventory augmentations may be filled in by interpolations at this stage (if
   possible).</p>
<p>3) Finally, convert the interpolated CostSpec instances to Cost instances.</p>
<p>Improving on this algorithm would require running a loop over the booking and
interpolation steps until all numbers are resolved or no more inference can
occur. We may consider that for later, as an experimental feature. My hunch is
that there are so few cases for which this would be useful that we won't bother
improving on the algorithm above.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.CategorizationError">
<code>CategorizationError</code>
<a class="headerlink" href="#beancount.parser.booking_full.CategorizationError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>CategorizationError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.CategorizationError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.CategorizationError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.CategorizationError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.CategorizationError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of CategorizationError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.CategorizationError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.CategorizationError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.InterpolationError">
<code>InterpolationError</code>
<a class="headerlink" href="#beancount.parser.booking_full.InterpolationError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>InterpolationError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.InterpolationError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.InterpolationError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.InterpolationError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.InterpolationError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of InterpolationError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.InterpolationError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.InterpolationError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.MissingType">
<code>MissingType</code>
<a class="headerlink" href="#beancount.parser.booking_full.MissingType" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>The type of missing number.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.ReductionError">
<code>ReductionError</code>
<a class="headerlink" href="#beancount.parser.booking_full.ReductionError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>ReductionError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.ReductionError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.ReductionError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.ReductionError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.ReductionError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of ReductionError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.ReductionError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.ReductionError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.Refer">
<code>Refer</code>
<a class="headerlink" href="#beancount.parser.booking_full.Refer" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Refer(index, units_currency, cost_currency, price_currency)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.Refer.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.Refer.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.Refer.__new__">
<code class="highlight language-python">
__new__
(_cls, index, units_currency, cost_currency, price_currency)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.Refer.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of Refer(index, units_currency, cost_currency, price_currency)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.Refer.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.Refer.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.SelfReduxError">
<code>SelfReduxError</code>
<a class="headerlink" href="#beancount.parser.booking_full.SelfReduxError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>SelfReduxError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.SelfReduxError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.SelfReduxError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.SelfReduxError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.SelfReduxError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of SelfReduxError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_full.SelfReduxError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_full.SelfReduxError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.book">
<code class="highlight language-python">
book
(entries, options_map, methods)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.book" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Interpolate missing data from the entries using the full historical algorithm.
See the internal implementation _book() for details.
This method only stripes some of the return values.</p>
<p>See _book() for arguments and return values.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def book(entries, options_map, methods):
    """Interpolate missing data from the entries using the full historical algorithm.
    See the internal implementation _book() for details.
    This method only stripes some of the return values.

    See _book() for arguments and return values.
    """
    entries, errors, _ = _book(entries, options_map, methods)
    return entries, errors
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.book_reductions">
<code class="highlight language-python">
book_reductions
(entry, group_postings, balances, methods)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.book_reductions" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Book inventory reductions against the ante-balances.</p>
<p>This function accepts a dict of (account, Inventory balance) and for each
posting that is a reduction against its inventory, attempts to find a
corresponding lot or list of lots to reduce the balance with.</p>
<ul>
<li>
<p>For reducing lots, the CostSpec instance of the posting is replaced by a
  Cost instance.</p>
</li>
<li>
<p>For augmenting lots, the CostSpec instance of the posting is left alone,
  except for its date, which is inherited from the parent Transaction.</p>
</li>
</ul>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entry</code></td>
<td><code></code></td>
<td>
<p>An instance of Transaction. This is only used to refer to when
logging errors.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>group_postings</code></td>
<td><code></code></td>
<td>
<p>A list of Posting instances for the group.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>balances</code></td>
<td><code></code></td>
<td>
<p>A dict of account name to inventory contents.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>methods</code></td>
<td><code></code></td>
<td>
<p>A mapping of account name to their corresponding booking
method enum.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A pair of
  booked_postings</code></td>
<td>
<p>A list of booked postings, with reducing lots resolved
    against specific position in the corresponding accounts'
    ante-inventory balances. Note single reducing posting in the input may
    result in multiple postings in the output. Also note that augmenting
    postings held-at-cost will still refer to 'cost' instances of
    CostSpec, left to be interpolated later.
  errors: A list of errors, if there were any.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def book_reductions(entry, group_postings, balances,
                    methods):
    """Book inventory reductions against the ante-balances.

    This function accepts a dict of (account, Inventory balance) and for each
    posting that is a reduction against its inventory, attempts to find a
    corresponding lot or list of lots to reduce the balance with.

    * For reducing lots, the CostSpec instance of the posting is replaced by a
      Cost instance.

    * For augmenting lots, the CostSpec instance of the posting is left alone,
      except for its date, which is inherited from the parent Transaction.

    Args:
      entry: An instance of Transaction. This is only used to refer to when
        logging errors.
      group_postings: A list of Posting instances for the group.
      balances: A dict of account name to inventory contents.
      methods: A mapping of account name to their corresponding booking
        method enum.
    Returns:
      A pair of
        booked_postings: A list of booked postings, with reducing lots resolved
          against specific position in the corresponding accounts'
          ante-inventory balances. Note single reducing posting in the input may
          result in multiple postings in the output. Also note that augmenting
          postings held-at-cost will still refer to 'cost' instances of
          CostSpec, left to be interpolated later.
        errors: A list of errors, if there were any.
    """
    errors = []

    # A local copy of the balances dictionary which is updated just for the
    # duration of this function's updates, in order to take into account the
    # cumulative effect of all the postings inferred here
    local_balances = {}

    empty = inventory.Inventory()
    booked_postings = []
    for posting in group_postings:
        # Process a single posting.
        units = posting.units
        costspec = posting.cost
        account = posting.account

        # Note: We ensure there is no mutation on 'balances' to keep this
        # function without side-effects. Note that we may be able to optimize
        # performance later on by giving up this property.
        #
        # Also note that if there is no existing balance, then won't be any lot
        # reduction because none of the postings will be able to match against
        # any currencies of the balance.
        previous_balance = balances.get(account, empty)
        balance = local_balances.setdefault(account, copy.copy(previous_balance))

        # Check if this is a lot held at cost.
        if costspec is None or units.number is MISSING:
            # This posting is not held at cost; we do nothing.
            booked_postings.append(posting)
        else:
            # This posting is held at cost; figure out if it's a reduction or an
            # augmentation.
            method = methods[account]
            if (method is not Booking.NONE and
                balance is not None and
                balance.is_reduced_by(units)):
                # This posting is a reduction.

                # Match the positions.
                cost_number = compute_cost_number(costspec, units)
                matches = []
                for position in balance:
                    # Skip inventory contents of a different currency.
                    if (units.currency and
                        position.units.currency != units.currency):
                        continue
                    # Skip balance positions not held at cost.
                    if position.cost is None:
                        continue
                    if (cost_number is not None and
                        position.cost.number != cost_number):
                        continue
                    if (isinstance(costspec.currency, str) and
                        position.cost.currency != costspec.currency):
                        continue
                    if (costspec.date and
                        position.cost.date != costspec.date):
                        continue
                    if (costspec.label and
                        position.cost.label != costspec.label):
                        continue
                    matches.append(position)

                # Check for ambiguous matches.
                if len(matches) == 0:
                    errors.append(
                        ReductionError(entry.meta,
                                       'No position matches "{}" against balance {}'.format(
                                           posting, balance),
                                       entry))
                    return [], errors  # This is irreconcilable, remove these postings.

                reduction_postings, matched_postings, ambi_errors = (
                    booking_method.handle_ambiguous_matches(entry, posting, matches,
                                                            method))
                if ambi_errors:
                    errors.extend(ambi_errors)
                    return [], errors

                # Add the reductions to the resulting list of booked postings.
                booked_postings.extend(reduction_postings)

                # Update the local balance in order to avoid matching against
                # the same postings twice when processing multiple postings in
                # the same transaction. Note that we only do this for postings
                # held at cost because the other postings may need interpolation
                # in order to be resolved properly.
                for posting in reduction_postings:
                    balance.add_position(posting)
            else:
                # This posting is an augmentation.
                #
                # Note that we do not convert the CostSpec instances to Cost
                # instances, because we want to let the subsequent interpolation
                # process able to interpolate either the cost per-unit or the
                # total cost, separately.

                # Put in the date of the parent Transaction if there is no
                # explicit date specified on the spec.
                if costspec.date is None:
                    dated_costspec = costspec._replace(date=entry.date)
                    posting = posting._replace(cost=dated_costspec)

                # FIXME: Insert unique ids for trade tracking; right now this
                # creates ambiguous matches errors (and it shouldn't).
                # # Insert a unique label if there isn't one.
                # if posting.cost is not None and posting.cost.label is None:
                #     posting = posting._replace(
                #         cost=posting.cost._replace(label=unique_label()))

                booked_postings.append(posting)

    return booked_postings, errors
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.categorize_by_currency">
<code class="highlight language-python">
categorize_by_currency
(entry, balances)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.categorize_by_currency" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Group the postings by the currency they declare.</p>
<p>This is used to prepare the postings for the next stages: Interpolation and
booking will then be carried out separately on each currency group. At the
outset of this routine, we should have distinct groups of currencies without
any ambiguities regarding which currency they need to balance against.</p>
<p>Here's how this works.</p>
<ul>
<li>
<p>First we apply the constraint that cost-currency and price-currency must
  match, if there is both a cost and a price. This reduces the space of
  possibilities somewahte.</p>
</li>
<li>
<p>If the currency is explicitly specified, we put the posting in that
  currency's bucket.</p>
</li>
<li>
<p>If not, we have a few methods left to disambiguate the currency:</p>
</li>
<li>
<p>We look at the remaining postings... if they are all of a single
     currency, the posting must be in that currency too.</p>
</li>
<li>
<p>If we cannot do that, we inspect the contents of the inventory of the
     account for the posting. If all the contents are of a single currency,
     we use that one.</p>
</li>
</ul>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>postings</code></td>
<td><code></code></td>
<td>
<p>A list of incomplete postings to categorize.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>balances</code></td>
<td><code></code></td>
<td>
<p>A dict of currency to inventory contents before the transaction is
applied.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A list of (currency string, list of tuples) items describing each postings
and its interpolated currencies, and a list of generated errors for
currency interpolation. The entry's original postings are left unmodified.
Each tuple in the value-list contains</code></td>
<td>
<p>index: The posting index in the original entry.
  units_currency: The interpolated currency for units.
  cost_currency: The interpolated currency for cost.
  price_currency: The interpolated currency for price.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def categorize_by_currency(entry, balances):
    """Group the postings by the currency they declare.

    This is used to prepare the postings for the next stages: Interpolation and
    booking will then be carried out separately on each currency group. At the
    outset of this routine, we should have distinct groups of currencies without
    any ambiguities regarding which currency they need to balance against.

    Here's how this works.

    - First we apply the constraint that cost-currency and price-currency must
      match, if there is both a cost and a price. This reduces the space of
      possibilities somewahte.

    - If the currency is explicitly specified, we put the posting in that
      currency's bucket.

    - If not, we have a few methods left to disambiguate the currency:

      1. We look at the remaining postings... if they are all of a single
         currency, the posting must be in that currency too.

      2. If we cannot do that, we inspect the contents of the inventory of the
         account for the posting. If all the contents are of a single currency,
         we use that one.

    Args:
      postings: A list of incomplete postings to categorize.
      balances: A dict of currency to inventory contents before the transaction is
        applied.
    Returns:
      A list of (currency string, list of tuples) items describing each postings
      and its interpolated currencies, and a list of generated errors for
      currency interpolation. The entry's original postings are left unmodified.
      Each tuple in the value-list contains:
        index: The posting index in the original entry.
        units_currency: The interpolated currency for units.
        cost_currency: The interpolated currency for cost.
        price_currency: The interpolated currency for price.
    """
    errors = []

    groups = collections.defaultdict(list)
    sortdict = {}
    auto_postings = []
    unknown = []
    for index, posting in enumerate(entry.postings):
        units = posting.units
        cost = posting.cost
        price = posting.price

        # Extract and override the currencies locally.
        units_currency = (units.currency
                          if units is not MISSING and units is not None
                          else None)
        cost_currency = (cost.currency
                         if cost is not MISSING and cost is not None
                         else None)
        price_currency = (price.currency
                          if price is not MISSING and price is not None
                          else None)

        # First we apply the constraint that cost-currency and price-currency
        # must match, if there is both a cost and a price. This reduces the
        # space of possibilities somewhat.
        if cost_currency is MISSING and isinstance(price_currency, str):
            cost_currency = price_currency
        if price_currency is MISSING and isinstance(cost_currency, str):
            price_currency = cost_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)

        if units is MISSING and price_currency is None:
            # Bucket auto-postings separately from unknown.
            auto_postings.append(refer)
        else:
            # Bucket with what we know so far.
            currency = get_bucket_currency(refer)
            if currency is not None:
                sortdict.setdefault(currency, index)
                groups[currency].append(refer)
            else:
                # If we need to infer the currency, store in unknown.
                unknown.append(refer)

    # We look at the remaining postings... if they are all of a single currency,
    # the posting must be in that currency too.
    if unknown and len(unknown) == 1 and len(groups) == 1:
        (index, units_currency, cost_currency, price_currency) = unknown.pop()

        other_currency = next(iter(groups.keys()))
        if price_currency is None and cost_currency is None:
            # Infer to the units currency.
            units_currency = other_currency
        else:
            # Infer to the cost and price currencies.
            if price_currency is MISSING:
                price_currency = other_currency
            if cost_currency is MISSING:
                cost_currency = other_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)
        currency = get_bucket_currency(refer)
        assert currency is not None
        sortdict.setdefault(currency, index)
        groups[currency].append(refer)

    # Finally, try to resolve all the unknown legs using the inventory contents
    # of each account.
    for refer in unknown:
        (index, units_currency, cost_currency, price_currency) = refer
        posting = entry.postings[index]
        balance = balances.get(posting.account, None)
        if balance is None:
            balance = inventory.Inventory()

        if units_currency is MISSING:
            balance_currencies = balance.currencies()
            if len(balance_currencies) == 1:
                units_currency = balance_currencies.pop()

        if cost_currency is MISSING or price_currency is MISSING:
            balance_cost_currencies = balance.cost_currencies()
            if len(balance_cost_currencies) == 1:
                balance_cost_currency = balance_cost_currencies.pop()
                if price_currency is MISSING:
                    price_currency = balance_cost_currency
                if cost_currency is MISSING:
                    cost_currency = balance_cost_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)
        currency = get_bucket_currency(refer)
        if currency is not None:
            sortdict.setdefault(currency, index)
            groups[currency].append(refer)
        else:
            errors.append(
                CategorizationError(posting.meta,
                                    "Failed to categorize posting {}".format(index + 1),
                                    entry))

    # Fill in missing units currencies if some remain as missing. This may occur
    # if we used the cost or price to bucket the currency but the units currency
    # was missing.
    for currency, refers in groups.items():
        for rindex, refer in enumerate(refers):
            if refer.units_currency is MISSING:
                posting = entry.postings[refer.index]
                balance = balances.get(posting.account, None)
                if balance is None:
                    continue
                balance_currencies = balance.currencies()
                if len(balance_currencies) == 1:
                    refers[rindex] = refer._replace(units_currency=balance_currencies.pop())

    # Deal with auto-postings.
    if len(auto_postings) &gt; 1:
        refer = auto_postings[-1]
        posting = entry.postings[refer.index]
        errors.append(
            CategorizationError(posting.meta,
                                "You may not have more than one auto-posting per currency",
                                entry))
        auto_postings = auto_postings[0:1]
    for refer in auto_postings:
        for currency in groups.keys():
            sortdict.setdefault(currency, refer.index)
            groups[currency].append(Refer(refer.index, currency, None, None))

    # Issue error for all currencies which we could not resolve.
    for currency, refers in groups.items():
        for refer in refers:
            posting = entry.postings[refer.index]
            for currency, name in [(refer.units_currency, 'units'),
                                   (refer.cost_currency, 'cost'),
                                   (refer.price_currency, 'price')]:
                if currency is MISSING:
                    errors.append(CategorizationError(
                        posting.meta,
                        "Could not resolve {} currency".format(name),
                        entry))

    sorted_groups = sorted(groups.items(), key=lambda item: sortdict[item[0]])
    return sorted_groups, errors
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.compute_cost_number">
<code class="highlight language-python">
compute_cost_number
(costspec, units)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.compute_cost_number" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Given a CostSpec, return the cost number, if possible to compute.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>costspec</code></td>
<td><code></code></td>
<td>
<p>A parsed instance of CostSpec.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>units</code></td>
<td><code></code></td>
<td>
<p>An instance of Amount for the units of the position.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>If it is not possible to calculate the cost, return None.
Otherwise, returns a Decimal instance, the per-unit cost.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def compute_cost_number(costspec, units):
    """Given a CostSpec, return the cost number, if possible to compute.

    Args:
      costspec: A parsed instance of CostSpec.
      units: An instance of Amount for the units of the position.
    Returns:
      If it is not possible to calculate the cost, return None.
      Otherwise, returns a Decimal instance, the per-unit cost.
    """
    number_per = costspec.number_per
    number_total = costspec.number_total
    if MISSING in (number_per, number_total):
        return None
    if number_total is not None:
        # Compute the per-unit cost if there is some total cost
        # component involved.
        cost_total = number_total
        units_number = units.number
        if number_per is not None:
            cost_total += number_per * units_number
        unit_cost = cost_total / abs(units_number)
    elif number_per is None:
        return None
    else:
        unit_cost = number_per
    return unit_cost
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.convert_costspec_to_cost">
<code class="highlight language-python">
convert_costspec_to_cost
(posting)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.convert_costspec_to_cost" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Convert an instance of CostSpec to Cost, if present on the posting.</p>
<p>If the posting has no cost, it itself is just returned.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>posting</code></td>
<td><code></code></td>
<td>
<p>An instance of Posting.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of Posting with a possibly replaced 'cost' attribute.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def convert_costspec_to_cost(posting):
    """Convert an instance of CostSpec to Cost, if present on the posting.

    If the posting has no cost, it itself is just returned.

    Args:
      posting: An instance of Posting.
    Returns:
      An instance of Posting with a possibly replaced 'cost' attribute.
    """
    cost = posting.cost
    if isinstance(cost, position.CostSpec):
        if cost is not None:
            units_number = posting.units.number
            number_per = cost.number_per
            number_total = cost.number_total
            if number_total is not None:
                # Compute the per-unit cost if there is some total cost
                # component involved.
                cost_total = number_total
                if number_per is not MISSING:
                    cost_total += number_per * units_number
                unit_cost = cost_total / abs(units_number)
            else:
                unit_cost = number_per
            new_cost = Cost(unit_cost, cost.currency, cost.date, cost.label)
            posting = posting._replace(units=posting.units, cost=new_cost)
    return posting
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.get_bucket_currency">
<code class="highlight language-python">
get_bucket_currency
(refer)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.get_bucket_currency" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Given currency references for a posting, return the bucket currency.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>refer</code></td>
<td><code></code></td>
<td>
<p>An instance of Refer.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A currency string.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_bucket_currency(refer):
    """Given currency references for a posting, return the bucket currency.

    Args:
      refer: An instance of Refer.
    Returns:
      A currency string.
    """
    currency = None
    if isinstance(refer.cost_currency, str):
        currency = refer.cost_currency
    elif isinstance(refer.price_currency, str):
        currency = refer.price_currency
    elif (refer.cost_currency is None and
          refer.price_currency is None and
          isinstance(refer.units_currency, str)):
        currency = refer.units_currency
    return currency
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.has_self_reduction">
<code class="highlight language-python">
has_self_reduction
(postings, methods)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.has_self_reduction" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return true if the postings potentially reduce each other at cost.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>postings</code></td>
<td><code></code></td>
<td>
<p>A list of postings with uninterpolated CostSpec cost instances.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>methods</code></td>
<td><code></code></td>
<td>
<p>A mapping of account name to their corresponding booking
method.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A boolean, true if there's a potential for self-reduction.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def has_self_reduction(postings, methods):
    """Return true if the postings potentially reduce each other at cost.

    Args:
      postings: A list of postings with uninterpolated CostSpec cost instances.
      methods: A mapping of account name to their corresponding booking
        method.
    Returns:
      A boolean, true if there's a potential for self-reduction.
    """
    # A mapping of (currency, cost-currency) and sign.
    cost_changes = {}
    for posting in postings:
        cost = posting.cost
        if cost is None:
            continue
        if methods[posting.account] is Booking.NONE:
            continue
        key = (posting.account, posting.units.currency)
        sign = 1 if posting.units.number &gt; ZERO else -1
        if cost_changes.setdefault(key, sign) != sign:
            return True
    return False
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.interpolate_group">
<code class="highlight language-python">
interpolate_group
(postings, balances, currency, tolerances)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.interpolate_group" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Interpolate missing numbers in the set of postings.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>postings</code></td>
<td><code></code></td>
<td>
<p>A list of Posting instances.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>balances</code></td>
<td><code></code></td>
<td>
<p>A dict of account to its ante-inventory.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currency</code></td>
<td><code></code></td>
<td>
<p>The weight currency of this group, used for reporting errors.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tolerances</code></td>
<td><code></code></td>
<td>
<p>A dict of currency to tolerance values.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A tuple of
  postings</code></td>
<td>
<p>A lit of new posting instances.
  errors: A list of errors generated during interpolation.
  interpolated: A boolean, true if we did have to interpolate.</p>
<p>In the case of an error, this returns the original list of postings, which
is still incomplete. If an error is returned, you should probably skip the
transaction altogether, or just not include the postings in it. (An
alternative behaviour would be to return only the list of valid postings,
but that would likely result in an unbalanced transaction. We do it this
way by choice.)</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def interpolate_group(postings, balances, currency, tolerances):
    """Interpolate missing numbers in the set of postings.

    Args:
      postings: A list of Posting instances.
      balances: A dict of account to its ante-inventory.
      currency: The weight currency of this group, used for reporting errors.
      tolerances: A dict of currency to tolerance values.
    Returns:
      A tuple of
        postings: A lit of new posting instances.
        errors: A list of errors generated during interpolation.
        interpolated: A boolean, true if we did have to interpolate.

      In the case of an error, this returns the original list of postings, which
      is still incomplete. If an error is returned, you should probably skip the
      transaction altogether, or just not include the postings in it. (An
      alternative behaviour would be to return only the list of valid postings,
      but that would likely result in an unbalanced transaction. We do it this
      way by choice.)
    """
    errors = []

    # Figure out which type of amount is missing, by creating a list of
    # incomplete postings and which type of units is missing.
    incomplete = []
    for index, posting in enumerate(postings):
        units = posting.units
        cost = posting.cost
        price = posting.price

        # Identify incomplete parts of the Posting components.
        if units.number is MISSING:
            incomplete.append((MissingType.UNITS, index))

        if isinstance(cost, CostSpec):
            if cost and cost.number_per is MISSING:
                incomplete.append((MissingType.COST_PER, index))
            if cost and cost.number_total is MISSING:
                incomplete.append((MissingType.COST_TOTAL, index))
        else:
            # Check that a resolved instance of Cost never needs interpolation.
            #
            # Note that in theory we could support the interpolation of regular
            # per-unit costs in these if we wanted to; but because they're all
            # reducing postings that have been booked earlier, those never need
            # to be interpolated.
            if cost is not None:
                assert isinstance(cost.number, Decimal), (
                    "Internal error: cost has no number: {}".format(cost))

        if price and price.number is MISSING:
            incomplete.append((MissingType.PRICE, index))

    # The replacement posting for the incomplete posting of this group.
    new_posting = None

    if len(incomplete) == 0:
        # If there are no missing numbers, just convert the CostSpec to Cost and
        # return that.
        out_postings = [convert_costspec_to_cost(posting)
                        for posting in postings]

    elif len(incomplete) &gt; 1:
        # If there is more than a single value to be interpolated, generate an
        # error and return no postings.
        _, posting_index = incomplete[0]
        errors.append(InterpolationError(
            postings[posting_index].meta,
            "Too many missing numbers for currency group '{}'".format(currency),
            None))
        out_postings = []

    else:
        # If there is a single missing number, calculate it and fill it in here.
        missing, index = incomplete[0]
        incomplete_posting = postings[index]

        # Convert augmenting postings' costs from CostSpec to corresponding Cost
        # instances, except for the incomplete posting.
        new_postings = [(posting
                         if posting is incomplete_posting
                         else convert_costspec_to_cost(posting))
                        for posting in postings]

        # Compute the balance of the other postings.
        residual = interpolate.compute_residual(posting
                                                for posting in new_postings
                                                if posting is not incomplete_posting)
        assert len(residual) &lt; 2, "Internal error in grouping postings by currencies."
        if not residual.is_empty():
            respos = next(iter(residual))
            assert respos.cost is None, (
                "Internal error; cost appears in weight calculation.")
            assert respos.units.currency == currency, (
                "Internal error; residual different than currency group.")
            weight = -respos.units.number
            weight_currency = respos.units.currency
        else:
            weight = ZERO
            weight_currency = currency

        if missing == MissingType.UNITS:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            if cost:
                # Handle the special case where we only have total cost.
                if cost.number_per == ZERO:
                    errors.append(InterpolationError(
                        incomplete_posting.meta,
                        "Cannot infer per-unit cost only from total", None))
                    return postings, errors, True

                assert cost.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                cost_total = cost.number_total or ZERO
                units_number = (weight - cost_total) / cost.number_per

            elif incomplete_posting.price:
                assert incomplete_posting.price.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                units_number = weight / incomplete_posting.price.number

            else:
                assert units.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                units_number = weight

            # Quantize the interpolated units if necessary.
            units_number = interpolate.quantize_with_tolerance(tolerances,
                                                               units.currency,
                                                               units_number)

            if weight != ZERO:
                new_pos = Position(Amount(units_number, units.currency), cost)
                new_posting = incomplete_posting._replace(units=new_pos.units,
                                                          cost=new_pos.cost)
            else:
                new_posting = None

        elif missing == MissingType.COST_PER:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            assert cost.currency == weight_currency, (
                "Internal error; residual currency different than missing currency.")
            if units.number != ZERO:
                number_per = (weight - (cost.number_total or ZERO)) / units.number
                new_cost = cost._replace(number_per=number_per)
                new_pos = Position(units, new_cost)
                new_posting = incomplete_posting._replace(units=new_pos.units,
                                                          cost=new_pos.cost)
            else:
                new_posting = None

        elif missing == MissingType.COST_TOTAL:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            assert cost.currency == weight_currency, (
                "Internal error; residual currency different than missing currency.")
            number_total = (weight - cost.number_per * units.number)
            new_cost = cost._replace(number_total=number_total)
            new_pos = Position(units, new_cost)
            new_posting = incomplete_posting._replace(units=new_pos.units,
                                                      cost=new_pos.cost)

        elif missing == MissingType.PRICE:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            if cost is not None:
                errors.append(InterpolationError(
                    incomplete_posting.meta,
                    "Cannot infer price for postings with units held at cost", None))
                return postings, errors, True
            else:
                price = incomplete_posting.price
                assert price.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                new_price_number = abs(weight / units.number)
                new_posting = incomplete_posting._replace(price=Amount(new_price_number,
                                                                       price.currency))

        else:
            assert False, "Internal error; Invalid missing type."

        # Replace the number in the posting.
        if new_posting is not None:
            # Set meta-data on the new posting to indicate it was interpolated.
            if new_posting.meta is None:
                new_posting = new_posting._replace(meta={})
            new_posting.meta[interpolate.AUTOMATIC_META] = True

            # Convert augmenting posting costs from CostSpec to a corresponding
            # Cost instance.
            new_postings[index] = convert_costspec_to_cost(new_posting)
        else:
            del new_postings[index]
        out_postings = new_postings

    assert all(not isinstance(posting.cost, CostSpec)
               for posting in out_postings)

    # Check that units are non-zero and that no cost remains negative; issue an
    # error if this is the case.
    for posting in out_postings:
        if posting.cost is None:
            continue
        # If there is a cost, we don't allow either a cost value of zero,
        # nor a zero number of units. Note that we allow a price of zero as
        # the only special case allowed (for conversion entries), but never
        # for costs.
        if posting.units.number == ZERO:
            errors.append(InterpolationError(
                posting.meta,
                'Amount is zero: "{}"'.format(posting.units), None))
        if posting.cost.number &lt; ZERO:
            errors.append(InterpolationError(
                posting.meta,
                'Cost is negative: "{}"'.format(posting.cost), None))

    return out_postings, errors, (new_posting is not None)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.replace_currencies">
<code class="highlight language-python">
replace_currencies
(postings, refer_groups)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.replace_currencies" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Replace resolved currencies in the entry's Postings.</p>
<p>This essentially applies the findings of categorize_by_currency() to produce
new postings with all currencies resolved.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>postings</code></td>
<td><code></code></td>
<td>
<p>A list of Posting instances to replace.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>refer_groups</code></td>
<td><code></code></td>
<td>
<p>A list of (currency, list of posting references) items as
returned by categorize_by_currency().</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new list of items of (currency, list of Postings), postings for which the
currencies have been replaced by their interpolated currency values.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def replace_currencies(postings, refer_groups):
    """Replace resolved currencies in the entry's Postings.

    This essentially applies the findings of categorize_by_currency() to produce
    new postings with all currencies resolved.

    Args:
      postings: A list of Posting instances to replace.
      refer_groups: A list of (currency, list of posting references) items as
        returned by categorize_by_currency().
    Returns:
      A new list of items of (currency, list of Postings), postings for which the
      currencies have been replaced by their interpolated currency values.
    """
    new_groups = []
    for currency, refers in refer_groups:
        new_postings = []
        for refer in sorted(refers, key=lambda r: r.index):
            posting = postings[refer.index]
            units = posting.units
            if units is MISSING or units is None:
                posting = posting._replace(units=Amount(MISSING, refer.units_currency))
            else:
                replace = False
                cost = posting.cost
                price = posting.price
                if units.currency is MISSING:
                    units = Amount(units.number, refer.units_currency)
                    replace = True
                if cost and cost.currency is MISSING:
                    cost = cost._replace(currency=refer.cost_currency)
                    replace = True
                if price and price.currency is MISSING:
                    price = Amount(price.number, refer.price_currency)
                    replace = True
                if replace:
                    posting = posting._replace(units=units, cost=cost, price=price)
            new_postings.append(posting)
        new_groups.append((currency, new_postings))
    return new_groups
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full.unique_label">
<code class="highlight language-python">
unique_label
()

        </code>
<a class="headerlink" href="#beancount.parser.booking_full.unique_label" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return a globally unique label for cost entries.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def unique_label() -&gt; Text:
    "Return a globally unique label for cost entries."
    return str(uuid.uuid4())
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking_full_test">
<code>booking_full_test</code>
<a class="headerlink" href="#beancount.parser.booking_full_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.TestBookAugmentations">
<code>TestBookAugmentations</code>
<a class="headerlink" href="#beancount.parser.booking_full_test.TestBookAugmentations" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Test that the augmentations are left alone by the book_reductions() function.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.TestCategorizeCurrencyGroup">
<code>TestCategorizeCurrencyGroup</code>
<a class="headerlink" href="#beancount.parser.booking_full_test.TestCategorizeCurrencyGroup" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Tests of per-currency categorization of postings.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.TestInterpolateCurrencyGroup">
<code>TestInterpolateCurrencyGroup</code>
<a class="headerlink" href="#beancount.parser.booking_full_test.TestInterpolateCurrencyGroup" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Tests the replacement of currencies inferred in the categorization step.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.TestReplaceCurrenciesInGroup">
<code>TestReplaceCurrenciesInGroup</code>
<a class="headerlink" href="#beancount.parser.booking_full_test.TestReplaceCurrenciesInGroup" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Tests the replacement of currencies inferred in the categorization step.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.book_test">
<code class="highlight language-python">
book_test
(method)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full_test.book_test" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A decorator factory for all booking tests. This calls _book() below.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">@test_utils.nottest
def book_test(method):
    "A decorator factory for all booking tests. This calls _book() below."
    def decorator(func):
        @parser.parse_doc(allow_incomplete=True)
        @functools.wraps(func)
        def wrapper(self, entries, unused_errors, options_map):
            self._book(entries, options_map, method)
            return func(self, entries, options_map)
        return wrapper
    return decorator
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.find_first_with_tag">
<code class="highlight language-python">
find_first_with_tag
(tag, entries, default=&lt;object object at 0x7f441084cf00&gt;)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full_test.find_first_with_tag" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return the first entry matching the given tag.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def find_first_with_tag(tag, entries, default=_UNSET):
    """Return the first entry matching the given tag."""
    found_entry = None
    for entry in entries:
        if tag in entry.tags:
            if found_entry is not None:
                raise KeyError("Multiple entries with tag #{}".format(tag))
            found_entry = entry
    if found_entry is not None:
        return found_entry
    if default is _UNSET:
        raise KeyError("Entry with tag #{} is missing".format(tag))
    return default
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.indexes">
<code class="highlight language-python">
indexes
(groups)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full_test.indexes" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return only the index sets from currency categorized groups.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def indexes(groups):
    """Return only the index sets from currency categorized groups."""
    return {currency: {refer[0] for refer in refers}
            for currency, refers in groups}
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_full_test.normalize_postings">
<code class="highlight language-python">
normalize_postings
(postings)

        </code>
<a class="headerlink" href="#beancount.parser.booking_full_test.normalize_postings" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Normalize a list of postings ready for direct comparison, for testing.</p>
<p>This sorts them by line order and removes metadata.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>postings</code></td>
<td><code></code></td>
<td>
<p>A list of Posting instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new reordered and normalized Posting instances.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_full_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def normalize_postings(postings):
    """Normalize a list of postings ready for direct comparison, for testing.

    This sorts them by line order and removes metadata.

    Args:
      postings: A list of Posting instances.
    Returns:
      A new reordered and normalized Posting instances.
    """
    return [posting._replace(meta=None)
            for posting in sorted(postings,
                                  key=lambda posting: posting.meta['lineno'])]
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking_method">
<code>booking_method</code>
<a class="headerlink" href="#beancount.parser.booking_method" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Implementations of all the particular booking methods.
This code is used by the full booking algorithm.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.AmbiguousMatchError">
<code>AmbiguousMatchError</code>
<a class="headerlink" href="#beancount.parser.booking_method.AmbiguousMatchError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>AmbiguousMatchError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_method.AmbiguousMatchError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_method.AmbiguousMatchError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of AmbiguousMatchError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_method.AmbiguousMatchError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_method.AmbiguousMatchError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.booking_method_AVERAGE">
<code class="highlight language-python">
booking_method_AVERAGE
(entry, posting, matches)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.booking_method_AVERAGE" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>AVERAGE booking method implementation.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def booking_method_AVERAGE(entry, posting, matches):
    """AVERAGE booking method implementation."""
    booked_reductions = []
    booked_matches = []
    errors = [AmbiguousMatchError(entry.meta, "AVERAGE method is not supported", entry)]
    return booked_reductions, booked_matches, errors, False

    # FIXME: Future implementation here.
    # pylint: disable=unreachable
    if False: # pylint: disable=using-constant-test
        # DISABLED - This is the code for AVERAGE, which is currently disabled.

        # If there is more than a single match we need to ultimately merge the
        # postings. Also, if the reducing posting provides a specific cost, we
        # need to update the cost basis as well. Both of these cases are carried
        # out by removing all the matches and readding them later on.
        if len(matches) == 1 and (
                not isinstance(posting.cost.number_per, Decimal) and
                not isinstance(posting.cost.number_total, Decimal)):
            # There is no cost. Just reduce the one leg. This should be the
            # normal case if we always merge augmentations and the user lets
            # Beancount deal with the cost.
            match = matches[0]
            sign = -1 if posting.units.number &lt; ZERO else 1
            number = min(abs(match.units.number), abs(posting.units.number))
            match_units = Amount(number * sign, match.units.currency)
            booked_reductions.append(posting._replace(units=match_units, cost=match.cost))
            insufficient = (match_units.number != posting.units.number)
        else:
            # Merge the matching postings to a single one.
            merged_units = inventory.Inventory()
            merged_cost = inventory.Inventory()
            for match in matches:
                merged_units.add_amount(match.units)
                merged_cost.add_amount(convert.get_weight(match))
            if len(merged_units) != 1 or len(merged_cost) != 1:
                errors.append(
                    AmbiguousMatchError(
                        entry.meta,
                        'Cannot merge positions in multiple currencies: {}'.format(
                            ', '.join(position.to_string(match_posting)
                                      for match_posting in matches)), entry))
            else:
                if (isinstance(posting.cost.number_per, Decimal) or
                    isinstance(posting.cost.number_total, Decimal)):
                    errors.append(
                        AmbiguousMatchError(
                            entry.meta,
                            "Explicit cost reductions aren't supported yet: {}".format(
                                position.to_string(posting)), entry))
                else:
                    # Insert postings to remove all the matches.
                    booked_reductions.extend(
                        posting._replace(units=-match.units, cost=match.cost,
                                         flag=flags.FLAG_MERGING)
                        for match in matches)
                    units = merged_units[0].units
                    date = matches[0].cost.date  ## FIXME: Select which one,
                                                 ## oldest or latest.
                    cost_units = merged_cost[0].units
                    cost = Cost(cost_units.number/units.number, cost_units.currency,
                                date, None)

                    # Insert a posting to refill those with a replacement match.
                    booked_reductions.append(
                        posting._replace(units=units, cost=cost, flag=flags.FLAG_MERGING))

                    # Now, match the reducing request against this lot.
                    booked_reductions.append(
                        posting._replace(units=posting.units, cost=cost))
                    insufficient = abs(posting.units.number) &gt; abs(units.number)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.booking_method_FIFO">
<code class="highlight language-python">
booking_method_FIFO
(entry, posting, matches)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.booking_method_FIFO" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>FIFO booking method implementation.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def booking_method_FIFO(entry, posting, matches):
    """FIFO booking method implementation."""
    return _booking_method_xifo(entry, posting, matches, False)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.booking_method_LIFO">
<code class="highlight language-python">
booking_method_LIFO
(entry, posting, matches)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.booking_method_LIFO" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>LIFO booking method implementation.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def booking_method_LIFO(entry, posting, matches):
    """LIFO booking method implementation."""
    return _booking_method_xifo(entry, posting, matches, True)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.booking_method_NONE">
<code class="highlight language-python">
booking_method_NONE
(entry, posting, matches)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.booking_method_NONE" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>NONE booking method implementation.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def booking_method_NONE(entry, posting, matches):
    """NONE booking method implementation."""

    # This never needs to match against any existing positions... we
    # disregard the matches, there's never any error. Note that this never
    # gets called in practice, we want to treat NONE postings as
    # augmentations. Default behaviour is to return them with their original
    # CostSpec, and the augmentation code will handle signaling an error if
    # there is insufficient detail to carry out the conversion to an
    # instance of Cost.

    # Note that it's an interesting question whether a reduction on an
    # account with NONE method which happens to match a single position
    # ought to be matched against it. We don't allow it for now.

    return [posting], [], False
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.booking_method_STRICT">
<code class="highlight language-python">
booking_method_STRICT
(entry, posting, matches)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.booking_method_STRICT" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Strict booking method.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entry</code></td>
<td><code></code></td>
<td>
<p>The parent Transaction instance.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>posting</code></td>
<td><code></code></td>
<td>
<p>An instance of Posting, the reducing posting which we're
attempting to match.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>matches</code></td>
<td><code></code></td>
<td>
<p>A list of matching Position instances from the ante-inventory.
Those positions are known to already match the 'posting' spec.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A triple of
  booked_reductions</code></td>
<td>
<p>A list of matched Posting instances, whose 'cost'
    attributes are ensured to be of type Cost.
  errors: A list of errors to be generated.
  insufficient: A boolean, true if we could not find enough matches
    to fulfill the reduction.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def booking_method_STRICT(entry, posting, matches):
    """Strict booking method.

    Args:
      entry: The parent Transaction instance.
      posting: An instance of Posting, the reducing posting which we're
        attempting to match.
      matches: A list of matching Position instances from the ante-inventory.
        Those positions are known to already match the 'posting' spec.
    Returns:
      A triple of
        booked_reductions: A list of matched Posting instances, whose 'cost'
          attributes are ensured to be of type Cost.
        errors: A list of errors to be generated.
        insufficient: A boolean, true if we could not find enough matches
          to fulfill the reduction.
    """
    booked_reductions = []
    booked_matches = []
    errors = []
    insufficient = False
    # In strict mode, we require at most a single matching posting.
    if len(matches) &gt; 1:
        # If the total requested to reduce matches the sum of all the
        # ambiguous postings, match against all of them.
        sum_matches = sum(p.units.number for p in matches)
        if sum_matches == -posting.units.number:
            booked_reductions.extend(
                posting._replace(units=-match.units, cost=match.cost)
                for match in matches)
        else:
            errors.append(
                AmbiguousMatchError(entry.meta,
                                    'Ambiguous matches for "{}": {}'.format(
                                        position.to_string(posting),
                                        ', '.join(position.to_string(match_posting)
                                                  for match_posting in matches)),
                                    entry))
    else:
        # Replace the posting's units and cost values.
        match = matches[0]
        sign = -1 if posting.units.number &lt; ZERO else 1
        number = min(abs(match.units.number), abs(posting.units.number))
        match_units = Amount(number * sign, match.units.currency)
        booked_reductions.append(posting._replace(units=match_units, cost=match.cost))
        booked_matches.append(match)
        insufficient = (match_units.number != posting.units.number)

    return booked_reductions, booked_matches, errors, insufficient
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_method.handle_ambiguous_matches">
<code class="highlight language-python">
handle_ambiguous_matches
(entry, posting, matches, method)

        </code>
<a class="headerlink" href="#beancount.parser.booking_method.handle_ambiguous_matches" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Handle ambiguous matches by dispatching to a particular method.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entry</code></td>
<td><code></code></td>
<td>
<p>The parent Transaction instance.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>posting</code></td>
<td><code></code></td>
<td>
<p>An instance of Posting, the reducing posting which we're
attempting to match.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>matches</code></td>
<td><code></code></td>
<td>
<p>A list of matching Position instances from the ante-inventory.
Those positions are known to already match the 'posting' spec.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>methods</code></td>
<td><code></code></td>
<td>
<p>A mapping of account name to their corresponding booking
method.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A pair of
  booked_reductions</code></td>
<td>
<p>A list of matched Posting instances, whose 'cost'
    attributes are ensured to be of type Cost.
  errors: A list of errors to be generated.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def handle_ambiguous_matches(entry, posting, matches, method):
    """Handle ambiguous matches by dispatching to a particular method.

    Args:
      entry: The parent Transaction instance.
      posting: An instance of Posting, the reducing posting which we're
        attempting to match.
      matches: A list of matching Position instances from the ante-inventory.
        Those positions are known to already match the 'posting' spec.
      methods: A mapping of account name to their corresponding booking
        method.
    Returns:
      A pair of
        booked_reductions: A list of matched Posting instances, whose 'cost'
          attributes are ensured to be of type Cost.
        errors: A list of errors to be generated.
    """
    assert isinstance(method, Booking), (
        "Invalid type: {}".format(method))
    assert matches, "Internal error: Invalid call with no matches"

    #method = globals()['booking_method_{}'.format(method.name)]
    method = _BOOKING_METHODS[method]
    (booked_reductions,
     booked_matches, errors, insufficient) = method(entry, posting, matches)
    if insufficient:
        errors.append(
            AmbiguousMatchError(entry.meta,
                           'Not enough lots to reduce "{}": {}'.format(
                               position.to_string(posting),
                               ', '.join(position.to_string(match_posting)
                                         for match_posting in matches)),
                           entry))

    return booked_reductions, booked_matches, errors
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking_method_test">
<code>booking_method_test</code>
<a class="headerlink" href="#beancount.parser.booking_method_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Tests for individual booking methods.</p>
<p>Note that these should be already covered by the tests in booking_full_test, but
we may want to add more tests here, just calling each method directly and
covering all the possible branches.</p>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.booking_test">
<code>booking_test</code>
<a class="headerlink" href="#beancount.parser.booking_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_test.BookingTestError">
<code>BookingTestError</code>
<a class="headerlink" href="#beancount.parser.booking_test.BookingTestError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>BookingTestError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_test.BookingTestError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_test.BookingTestError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_test.BookingTestError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_test.BookingTestError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of BookingTestError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_test.BookingTestError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.booking_test.BookingTestError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.booking_test.TestBookingValidation">
<code>TestBookingValidation</code>
<a class="headerlink" href="#beancount.parser.booking_test.TestBookingValidation" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.booking_test.TestBookingValidation.setUp">
<code class="highlight language-python">
setUp
(self)

        </code>
<a class="headerlink" href="#beancount.parser.booking_test.TestBookingValidation.setUp" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Hook method for setting up the test fixture before exercising it.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def setUp(self):
    self.input_str = textwrap.dedent("""

    2014-01-01 open Assets:Investments:Cash
    2014-01-01 open Assets:Investments:Stock

    2014-06-22 * "Add some positive units"
      Assets:Investments:Stock    1 HOOL {500 USD}
      Assets:Investments:Cash  -500 USD

    2014-06-23 * "Down to zero"
      Assets:Investments:Stock   -1 HOOL {500 USD}
      Assets:Investments:Cash   500 USD

    2014-06-24 * "Go negative from zero"
      Assets:Investments:Stock   -1 HOOL {500 USD}
      Assets:Investments:Cash   500 USD

    2014-06-25 * "Go positive much"
      Assets:Investments:Stock    11 HOOL {500 USD}
      Assets:Investments:Cash  -5500 USD

    2014-06-26 * "Cross to negative from above zero"
      Assets:Investments:Stock  -15 HOOL {500 USD}
      Assets:Investments:Cash  7500 USD

    """)
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_test.convert_lot_specs_to_lots">
<code class="highlight language-python">
convert_lot_specs_to_lots
(entries)

        </code>
<a class="headerlink" href="#beancount.parser.booking_test.convert_lot_specs_to_lots" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>For all the entries, convert the posting's position's CostSpec to Cost
instances. In the simple method, the data provided in the CostSpec must
unambiguously provide a way to compute the cost amount.</p>
<p>This essentially replicates the way the old parser used to work, but
allowing positions to have the fuzzy lot specifications instead of the
resolved ones. We used to simply compute the costs locally, and this gets
rid of the CostSpec to produce the Cost without fuzzy matching. This is only
there for the sake of transition to the new matching logic.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A list of incomplete directives as per the parser.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of entries whose postings's position costs have been converted to
Cost instances but that may still be incomplete.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If there's a unacceptable number.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def convert_lot_specs_to_lots(entries):
    """For all the entries, convert the posting's position's CostSpec to Cost
    instances. In the simple method, the data provided in the CostSpec must
    unambiguously provide a way to compute the cost amount.

    This essentially replicates the way the old parser used to work, but
    allowing positions to have the fuzzy lot specifications instead of the
    resolved ones. We used to simply compute the costs locally, and this gets
    rid of the CostSpec to produce the Cost without fuzzy matching. This is only
    there for the sake of transition to the new matching logic.

    Args:
      entries: A list of incomplete directives as per the parser.
    Returns:
      A list of entries whose postings's position costs have been converted to
      Cost instances but that may still be incomplete.
    Raises:
      ValueError: If there's a unacceptable number.
    """
    new_entries = []
    errors = []
    for entry in entries:
        if not isinstance(entry, Transaction):
            new_entries.append(entry)
            continue

        new_postings = []
        for posting in entry.postings:
            try:
                units = posting.units
                cost_spec = posting.cost
                cost = convert_spec_to_cost(units, cost_spec)
                if cost_spec is not None and cost is None:
                    errors.append(
                        BookingTestError(entry.meta,
                                         "Cost syntax not supported; cost spec ignored",
                                         None))

                if cost and isinstance(units, Amount):
                    # If there is a cost, we don't allow either a cost value of
                    # zero, nor a zero number of units. Note that we allow a price
                    # of zero as the only special case (for conversion entries), but
                    # never for costs.
                    if units.number == ZERO:
                        raise ValueError('Amount is zero: "{}"'.format(units))
                    if cost.number is not None and cost.number &lt; ZERO:
                        raise ValueError('Cost is negative: "{}"'.format(cost))
            except ValueError as exc:
                errors.append(BookingTestError(entry.meta, str(exc), None))
                cost = None
            new_postings.append(posting._replace(cost=cost))
        new_entries.append(entry._replace(postings=new_postings))
    return new_entries, errors
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.booking_test.convert_spec_to_cost">
<code class="highlight language-python">
convert_spec_to_cost
(units, cost_spec)

        </code>
<a class="headerlink" href="#beancount.parser.booking_test.convert_spec_to_cost" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Convert a posting's CostSpec instance to a Cost.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>units</code></td>
<td><code></code></td>
<td>
<p>An instance of Amount.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cost_spec</code></td>
<td><code></code></td>
<td>
<p>An instance of CostSpec.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of Cost.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/booking_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def convert_spec_to_cost(units, cost_spec):
    """Convert a posting's CostSpec instance to a Cost.

    Args:
      units: An instance of Amount.
      cost_spec: An instance of CostSpec.
    Returns:
      An instance of Cost.
    """
    cost = cost_spec
    errors = []
    if isinstance(units, Amount):
        currency = units.currency
        if cost_spec is not None:
            number_per, number_total, cost_currency, date, label, merge = cost_spec

            # Compute the cost.
            if number_per is not MISSING or number_total is not None:
                if number_total is not None:
                    # Compute the per-unit cost if there is some total cost
                    # component involved.
                    units_num = units.number
                    cost_total = number_total
                    if number_per is not MISSING:
                        cost_total += number_per * units_num
                    unit_cost = cost_total / abs(units_num)
                else:
                    unit_cost = number_per
                cost = Cost(unit_cost, cost_currency, date, label)
            else:
                cost = None
    return cost
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.cmptest">
<code>cmptest</code>
<a class="headerlink" href="#beancount.parser.cmptest" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Support utillities for testing scripts.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.cmptest.TestError">
<code>TestError</code>
<a class="headerlink" href="#beancount.parser.cmptest.TestError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Errors within the test implementation itself. These should never occur.</p>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.cmptest.assertEqualEntries">
<code class="highlight language-python">
assertEqualEntries
(expected_entries, actual_entries, failfunc=&lt;function fail at 0x7f441097a040&gt;, allow_incomplete=False)

        </code>
<a class="headerlink" href="#beancount.parser.cmptest.assertEqualEntries" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Compare two lists of entries exactly and print missing entries verbosely if
they occur.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expected_entries</code></td>
<td><code></code></td>
<td>
<p>Either a list of directives or a string, in which case the
string is run through beancount.parser.parse_string() and the resulting
list is used.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>actual_entries</code></td>
<td><code></code></td>
<td>
<p>Same treatment as expected_entries, the other list of
directives to compare to.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>failfunc</code></td>
<td><code></code></td>
<td>
<p>A function to call on failure.</p>
</td>
<td><code>&lt;function fail at 0x7f441097a040&gt;</code></td>
</tr>
<tr>
<td><code>allow_incomplete</code></td>
<td><code></code></td>
<td>
<p>A boolean, true if we allow incomplete inputs and perform
light-weight booking.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AssertionError</code></td>
<td>
<p>If the exception fails.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def assertEqualEntries(expected_entries, actual_entries,
                       failfunc=DEFAULT_FAILFUNC, allow_incomplete=False):
    """Compare two lists of entries exactly and print missing entries verbosely if
    they occur.

    Args:
      expected_entries: Either a list of directives or a string, in which case the
        string is run through beancount.parser.parse_string() and the resulting
        list is used.
      actual_entries: Same treatment as expected_entries, the other list of
        directives to compare to.
      failfunc: A function to call on failure.
      allow_incomplete: A boolean, true if we allow incomplete inputs and perform
        light-weight booking.
    Raises:
      AssertionError: If the exception fails.
    """
    expected_entries = read_string_or_entries(expected_entries, allow_incomplete)
    actual_entries = read_string_or_entries(actual_entries, allow_incomplete)

    same, expected_missing, actual_missing = compare.compare_entries(expected_entries,
                                                                     actual_entries)
    if not same:
        assert expected_missing or actual_missing, "Missing is missing: {}, {}".format(
            expected_missing, actual_missing)
        oss = io.StringIO()
        if expected_missing:
            oss.write("Present in expected set and not in actual set:\n\n")
            for entry in expected_missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        if actual_missing:
            oss.write("Present in actual set and not in expected set:\n\n")
            for entry in actual_missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        failfunc(oss.getvalue())
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.cmptest.assertExcludesEntries">
<code class="highlight language-python">
assertExcludesEntries
(subset_entries, entries, failfunc=&lt;function fail at 0x7f441097a040&gt;, allow_incomplete=False)

        </code>
<a class="headerlink" href="#beancount.parser.cmptest.assertExcludesEntries" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Check that subset_entries is not included in entries and print extra entries.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>subset_entries</code></td>
<td><code></code></td>
<td>
<p>Either a list of directives or a string, in which case the
string is run through beancount.parser.parse_string() and the resulting
list is used.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>Same treatment as subset_entries, the other list of
directives to compare to.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>failfunc</code></td>
<td><code></code></td>
<td>
<p>A function to call on failure.</p>
</td>
<td><code>&lt;function fail at 0x7f441097a040&gt;</code></td>
</tr>
<tr>
<td><code>allow_incomplete</code></td>
<td><code></code></td>
<td>
<p>A boolean, true if we allow incomplete inputs and perform
light-weight booking.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AssertionError</code></td>
<td>
<p>If the exception fails.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def assertExcludesEntries(subset_entries, entries,
                          failfunc=DEFAULT_FAILFUNC, allow_incomplete=False):
    """Check that subset_entries is not included in entries and print extra entries.

    Args:
      subset_entries: Either a list of directives or a string, in which case the
        string is run through beancount.parser.parse_string() and the resulting
        list is used.
      entries: Same treatment as subset_entries, the other list of
        directives to compare to.
      failfunc: A function to call on failure.
      allow_incomplete: A boolean, true if we allow incomplete inputs and perform
        light-weight booking.
    Raises:
      AssertionError: If the exception fails.
    """
    subset_entries = read_string_or_entries(subset_entries, allow_incomplete)
    entries = read_string_or_entries(entries)

    excludes, extra = compare.excludes_entries(subset_entries, entries)
    if not excludes:
        assert extra, "Extra is empty: {}".format(extra)
        oss = io.StringIO()
        if extra:
            oss.write("Extra from from first/excluded set:\n\n")
            for entry in extra:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        failfunc(oss.getvalue())
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.cmptest.assertIncludesEntries">
<code class="highlight language-python">
assertIncludesEntries
(subset_entries, entries, failfunc=&lt;function fail at 0x7f441097a040&gt;, allow_incomplete=False)

        </code>
<a class="headerlink" href="#beancount.parser.cmptest.assertIncludesEntries" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Check that subset_entries is included in entries and print missing entries.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>subset_entries</code></td>
<td><code></code></td>
<td>
<p>Either a list of directives or a string, in which case the
string is run through beancount.parser.parse_string() and the resulting
list is used.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>Same treatment as subset_entries, the other list of
directives to compare to.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>failfunc</code></td>
<td><code></code></td>
<td>
<p>A function to call on failure.</p>
</td>
<td><code>&lt;function fail at 0x7f441097a040&gt;</code></td>
</tr>
<tr>
<td><code>allow_incomplete</code></td>
<td><code></code></td>
<td>
<p>A boolean, true if we allow incomplete inputs and perform
light-weight booking.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AssertionError</code></td>
<td>
<p>If the exception fails.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def assertIncludesEntries(subset_entries, entries,
                          failfunc=DEFAULT_FAILFUNC, allow_incomplete=False):
    """Check that subset_entries is included in entries and print missing entries.

    Args:
      subset_entries: Either a list of directives or a string, in which case the
        string is run through beancount.parser.parse_string() and the resulting
        list is used.
      entries: Same treatment as subset_entries, the other list of
        directives to compare to.
      failfunc: A function to call on failure.
      allow_incomplete: A boolean, true if we allow incomplete inputs and perform
        light-weight booking.
    Raises:
      AssertionError: If the exception fails.
    """
    subset_entries = read_string_or_entries(subset_entries, allow_incomplete)
    entries = read_string_or_entries(entries)

    includes, missing = compare.includes_entries(subset_entries, entries)
    if not includes:
        assert missing, "Missing is empty: {}".format(missing)
        oss = io.StringIO()
        if missing:
            oss.write("Missing from from expected set:\n\n")
            for entry in missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        failfunc(oss.getvalue())
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.cmptest.read_string_or_entries">
<code class="highlight language-python">
read_string_or_entries
(entries_or_str, allow_incomplete=False)

        </code>
<a class="headerlink" href="#beancount.parser.cmptest.read_string_or_entries" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Read a string of entries or just entries.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries_or_str</code></td>
<td><code></code></td>
<td>
<p>Either a list of directives, or a string containing directives.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>allow_incomplete</code></td>
<td><code></code></td>
<td>
<p>A boolean, true if we allow incomplete inputs and perform
light-weight booking.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of directives.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def read_string_or_entries(entries_or_str, allow_incomplete=False):
    """Read a string of entries or just entries.

    Args:
      entries_or_str: Either a list of directives, or a string containing directives.
      allow_incomplete: A boolean, true if we allow incomplete inputs and perform
        light-weight booking.
    Returns:
      A list of directives.
    """
    if isinstance(entries_or_str, str):
        entries, errors, options_map = parser.parse_string(
            textwrap.dedent(entries_or_str))

        if allow_incomplete:
            # Do a simplistic local conversion in order to call the comparison.
            entries = [_local_booking(entry) for entry in entries]
        else:
            # Don't accept incomplete entries either.
            if any(parser.is_entry_incomplete(entry) for entry in entries):
                raise TestError("Entries in assertions may not use interpolation.")

            entries, booking_errors = booking.book(entries, options_map)
            errors = errors + booking_errors

        # Don't tolerate errors.
        if errors:
            oss = io.StringIO()
            printer.print_errors(errors, file=oss)
            raise TestError("Unexpected errors in expected: {}".format(oss.getvalue()))

    else:
        assert isinstance(entries_or_str, list), "Expecting list: {}".format(entries_or_str)
        entries = entries_or_str

    return entries
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.cmptest_test">
<code>cmptest_test</code>
<a class="headerlink" href="#beancount.parser.cmptest_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Tests for cmptest base test class.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.cmptest_test.TestTestCase">
<code>TestTestCase</code>
<a class="headerlink" href="#beancount.parser.cmptest_test.TestTestCase" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.cmptest_test.TestTestCase.setUp">
<code class="highlight language-python">
setUp
(self)

        </code>
<a class="headerlink" href="#beancount.parser.cmptest_test.TestTestCase.setUp" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Hook method for setting up the test fixture before exercising it.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/cmptest_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def setUp(self):
    entries, parse_errors, options_map = parser.parse_string(self.ledger_text)
    self.entries, booking_errors = booking.book(entries, options_map)
    self.assertFalse(parse_errors)
    self.assertFalse(booking_errors)
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.grammar">
<code>grammar</code>
<a class="headerlink" href="#beancount.parser.grammar" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Builder for Beancount grammar.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.Builder">
<code>Builder</code>
<a class="headerlink" href="#beancount.parser.grammar.Builder" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A builder used by the lexer and grammar parser as callbacks to create
    the data objects corresponding to rules parsed from the input file.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.amount">
<code class="highlight language-python">
amount
(self, number, currency)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.amount" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an amount grammar rule.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>number</code></td>
<td><code></code></td>
<td>
<p>a Decimal instance, the number of the amount.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currency</code></td>
<td><code></code></td>
<td>
<p>a currency object (a str, really, see CURRENCY above)</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of Amount.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def amount(self, number, currency):
    """Process an amount grammar rule.

    Args:
      number: a Decimal instance, the number of the amount.
      currency: a currency object (a str, really, see CURRENCY above)
    Returns:
      An instance of Amount.
    """
    # Update the mapping that stores the parsed precisions.
    # Note: This is relatively slow, adds about 70ms because of number.as_tuple().
    self.dcupdate(number, currency)
    return Amount(number, currency)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.balance">
<code class="highlight language-python">
balance
(self, filename, lineno, date, account, amount, tolerance, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.balance" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an assertion directive.</p>
<p>We produce no errors here by default. We replace the failing ones in the
routine that does the verification later one, that these have succeeded
or failed.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the account to balance.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>amount</code></td>
<td><code></code></td>
<td>
<p>The expected amount, to be checked.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tolerance</code></td>
<td><code></code></td>
<td>
<p>The tolerance number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Balance object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def balance(self, filename, lineno, date, account, amount, tolerance, kvlist):
    """Process an assertion directive.

    We produce no errors here by default. We replace the failing ones in the
    routine that does the verification later one, that these have succeeded
    or failed.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to balance.
      amount: The expected amount, to be checked.
      tolerance: The tolerance number.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Balance object.
    """
    diff_amount = None
    meta = new_metadata(filename, lineno, kvlist)
    return Balance(meta, date, account, amount, tolerance, diff_amount)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.build_grammar_error">
<code class="highlight language-python">
build_grammar_error
(self, filename, lineno, exc_value, exc_type=None, exc_traceback=None)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.build_grammar_error" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Build a grammar error and appends it to the list of pending errors.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>excvalue</code></td>
<td><code></code></td>
<td>
<p>The exception value, or a str, the message of the error.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>exc_type</code></td>
<td><code></code></td>
<td>
<p>An exception type, if an exception occurred.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>exc_traceback</code></td>
<td><code></code></td>
<td>
<p>A traceback object.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def build_grammar_error(self, filename, lineno, exc_value,
                        exc_type=None, exc_traceback=None):
    """Build a grammar error and appends it to the list of pending errors.

    Args:
      filename: The current filename
      lineno: The current line number
      excvalue: The exception value, or a str, the message of the error.
      exc_type: An exception type, if an exception occurred.
      exc_traceback: A traceback object.
    """
    if exc_type is not None:
        assert not isinstance(exc_value, str)
        strings = traceback.format_exception_only(exc_type, exc_value)
        tblist = traceback.extract_tb(exc_traceback)
        filename, lineno, _, __ = tblist[0]
        message = '{} ({}:{})'.format(strings[0], filename, lineno)
    else:
        message = str(exc_value)
    meta = new_metadata(filename, lineno)
    self.errors.append(
        ParserSyntaxError(meta, message, None))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.close">
<code class="highlight language-python">
close
(self, filename, lineno, date, account, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.close" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a close directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the name of the account.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Close object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def close(self, filename, lineno, date, account, kvlist):
    """Process a close directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the name of the account.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Close object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Close(meta, date, account)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.commodity">
<code class="highlight language-python">
commodity
(self, filename, lineno, date, currency, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.commodity" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a close directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currency</code></td>
<td><code></code></td>
<td>
<p>A string, the commodity being declared.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Close object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def commodity(self, filename, lineno, date, currency, kvlist):
    """Process a close directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      currency: A string, the commodity being declared.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Close object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Commodity(meta, date, currency)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.compound_amount">
<code class="highlight language-python">
compound_amount
(self, number_per, number_total, currency)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.compound_amount" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an amount grammar rule.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>number_per</code></td>
<td><code></code></td>
<td>
<p>a Decimal instance, the number of the cost per share.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>number_total</code></td>
<td><code></code></td>
<td>
<p>a Decimal instance, the number of the cost over all shares.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currency</code></td>
<td><code></code></td>
<td>
<p>a currency object (a str, really, see CURRENCY above)</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A triple of (Decimal, Decimal, currency string) to be processed further when
creating the final per-unit cost number.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def compound_amount(self, number_per, number_total, currency):
    """Process an amount grammar rule.

    Args:
      number_per: a Decimal instance, the number of the cost per share.
      number_total: a Decimal instance, the number of the cost over all shares.
      currency: a currency object (a str, really, see CURRENCY above)
    Returns:
      A triple of (Decimal, Decimal, currency string) to be processed further when
      creating the final per-unit cost number.
    """
    # Update the mapping that stores the parsed precisions.
    # Note: This is relatively slow, adds about 70ms because of number.as_tuple().
    self.dcupdate(number_per, currency)
    self.dcupdate(number_total, currency)

    # Note that we are not able to reduce the value to a number per-share
    # here because we only get the number of units in the full lot spec.
    return CompoundAmount(number_per, number_total, currency)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.cost_merge">
<code class="highlight language-python">
cost_merge
(self, _)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.cost_merge" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create a 'merge cost' token.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def cost_merge(self, _):
    """Create a 'merge cost' token."""
    return MERGE_COST
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.cost_spec">
<code class="highlight language-python">
cost_spec
(self, cost_comp_list, is_total)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.cost_spec" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a cost_spec grammar rule.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cost_comp_list</code></td>
<td><code></code></td>
<td>
<p>A list of CompoundAmount, a datetime.date, or
label ID strings.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>is_total</code></td>
<td><code></code></td>
<td>
<p>Assume only the total cost is specified; reject the &lt;number&gt; # &lt;number&gt;
  syntax, that is, no compound amounts may be specified. This is used to support
  the {{...}} syntax.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A cost-info tuple of CompoundAmount, lot date and label string. Any of these
may be set to a sentinel indicating "unset".</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def cost_spec(self, cost_comp_list, is_total):
    """Process a cost_spec grammar rule.

    Args:
      cost_comp_list: A list of CompoundAmount, a datetime.date, or
        label ID strings.
      is_total: Assume only the total cost is specified; reject the &lt;number&gt; # &lt;number&gt;
          syntax, that is, no compound amounts may be specified. This is used to support
          the {{...}} syntax.
    Returns:
      A cost-info tuple of CompoundAmount, lot date and label string. Any of these
      may be set to a sentinel indicating "unset".
    """
    if not cost_comp_list:
        return CostSpec(MISSING, None, MISSING, None, None, False)
    assert isinstance(cost_comp_list, list), (
        "Internal error in parser: {}".format(cost_comp_list))

    compound_cost = None
    date_ = None
    label = None
    merge = None
    for comp in cost_comp_list:
        if isinstance(comp, CompoundAmount):
            if compound_cost is None:
                compound_cost = comp
            else:
                self.errors.append(
                    ParserError(self.get_lexer_location(),
                                "Duplicate cost: '{}'.".format(comp), None))

        elif isinstance(comp, date):
            if date_ is None:
                date_ = comp
            else:
                self.errors.append(
                    ParserError(self.get_lexer_location(),
                                "Duplicate date: '{}'.".format(comp), None))

        elif comp is MERGE_COST:
            if merge is None:
                merge = True
                self.errors.append(
                    ParserError(self.get_lexer_location(),
                                "Cost merging is not supported yet", None))
            else:
                self.errors.append(
                    ParserError(self.get_lexer_location(),
                                "Duplicate merge-cost spec", None))

        else:
            assert isinstance(comp, str), (
                "Currency component is not string: '{}'".format(comp))
            if label is None:
                label = comp
            else:
                self.errors.append(
                    ParserError(self.get_lexer_location(),
                                "Duplicate label: '{}'.".format(comp), None))

    # If there was a cost_comp_list, thus a "{...}" cost basis spec, you must
    # indicate that by creating a CompoundAmount(), always.

    if compound_cost is None:
        number_per, number_total, currency = MISSING, None, MISSING
    else:
        number_per, number_total, currency = compound_cost
        if is_total:
            if number_total is not None:
                self.errors.append(
                    ParserError(
                        self.get_lexer_location(),
                        ("Per-unit cost may not be specified using total cost "
                         "syntax: '{}'; ignoring per-unit cost").format(compound_cost),
                        None))
                # Ignore per-unit number.
                number_per = ZERO
            else:
                # There's a single number specified; interpret it as a total cost.
                number_total = number_per
                number_per = ZERO

    if merge is None:
        merge = False

    return CostSpec(number_per, number_total, currency, date_, label, merge)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.custom">
<code class="highlight language-python">
custom
(self, filename, lineno, date, dir_type, custom_values, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.custom" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a custom directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dir_type</code></td>
<td><code></code></td>
<td>
<p>A string, a type for the custom directive being parsed.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>custom_values</code></td>
<td><code></code></td>
<td>
<p>A list of the various tokens seen on the same line.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Custom object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def custom(self, filename, lineno, date, dir_type, custom_values, kvlist):
    """Process a custom directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      dir_type: A string, a type for the custom directive being parsed.
      custom_values: A list of the various tokens seen on the same line.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Custom object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Custom(meta, date, dir_type, custom_values)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.custom_value">
<code class="highlight language-python">
custom_value
(self, value, dtype=None)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.custom_value" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create a custom value object, along with its type.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>One of the accepted custom values.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A pair of (value, dtype) where 'dtype' is the datatype is that of the
value.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def custom_value(self, value, dtype=None):
    """Create a custom value object, along with its type.

    Args:
      value: One of the accepted custom values.
    Returns:
      A pair of (value, dtype) where 'dtype' is the datatype is that of the
      value.
    """
    if dtype is None:
        dtype = type(value)
    return ValueType(value, dtype)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.dcupdate">
<code class="highlight language-python">
dcupdate
(self, number, currency)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.dcupdate" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Update the display context.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def dcupdate(self, number, currency):
    """Update the display context."""
    if isinstance(number, Decimal) and currency and currency is not MISSING:
        self._dcupdate(number, currency)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.document">
<code class="highlight language-python">
document
(self, filename, lineno, date, account, document_filename, tags_links, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.document" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a document directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>an Account instance.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>document_filename</code></td>
<td><code></code></td>
<td>
<p>a str, the name of the document file.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tags_links</code></td>
<td><code></code></td>
<td>
<p>The current TagsLinks accumulator.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Document object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def document(self, filename, lineno, date, account, document_filename, tags_links,
             kvlist):
    """Process a document directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      account: an Account instance.
      document_filename: a str, the name of the document file.
      tags_links: The current TagsLinks accumulator.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Document object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    if not path.isabs(document_filename):
        document_filename = path.abspath(path.join(path.dirname(filename),
                                                   document_filename))
    tags, links = self.finalize_tags_links(tags_links.tags, tags_links.links)
    return Document(meta, date, account, document_filename, tags, links)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.event">
<code class="highlight language-python">
event
(self, filename, lineno, date, event_type, description, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.event" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an event directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>event_type</code></td>
<td><code></code></td>
<td>
<p>a str, the name of the event type.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>description</code></td>
<td><code></code></td>
<td>
<p>a str, the event value, the contents.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Event object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def event(self, filename, lineno, date, event_type, description, kvlist):
    """Process an event directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      event_type: a str, the name of the event type.
      description: a str, the event value, the contents.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Event object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Event(meta, date, event_type, description)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.finalize">
<code class="highlight language-python">
finalize
(self)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.finalize" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Finalize the parser, check for final errors and return the triple.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A triple of
  entries</code></td>
<td>
<p>A list of parsed directives, which may need completion.
  errors: A list of errors, hopefully empty.
  options_map: A dict of options.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def finalize(self):
    """Finalize the parser, check for final errors and return the triple.

    Returns:
      A triple of
        entries: A list of parsed directives, which may need completion.
        errors: A list of errors, hopefully empty.
        options_map: A dict of options.
    """
    # If the user left some tags unbalanced, issue an error.
    for tag in self.tags:
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta, "Unbalanced pushed tag: '{}'".format(tag), None))

    # If the user left some metadata unpopped, issue an error.
    for key, value_list in self.meta.items():
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta, (
                "Unbalanced metadata key '{}'; leftover metadata '{}'").format(
                    key, ', '.join(value_list)), None))

    # Weave the commas option in the DisplayContext itself, so it propagates
    # everywhere it is used automatically.
    self.dcontext.set_commas(self.options['render_commas'])

    return (self.get_entries(), self.errors, self.get_options())
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.finalize_tags_links">
<code class="highlight language-python">
finalize_tags_links
(self, tags, links)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.finalize_tags_links" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Finally amend tags and links and return final objects to be inserted.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tags</code></td>
<td><code></code></td>
<td>
<p>A set of tag strings (warning: this gets mutated in-place).</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>links</code></td>
<td><code></code></td>
<td>
<p>A set of link strings.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A sanitized pair of (tags, links).</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def finalize_tags_links(self, tags, links):
    """Finally amend tags and links and return final objects to be inserted.

    Args:
      tags: A set of tag strings (warning: this gets mutated in-place).
      links: A set of link strings.
    Returns:
      A sanitized pair of (tags, links).
    """
    if self.tags:
        tags.update(self.tags)
    return (frozenset(tags) if tags else EMPTY_SET,
            frozenset(links) if links else EMPTY_SET)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.get_entries">
<code class="highlight language-python">
get_entries
(self)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.get_entries" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return the accumulated entries.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of sorted directives.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_entries(self):
    """Return the accumulated entries.

    Returns:
      A list of sorted directives.
    """
    return sorted(self.entries, key=data.entry_sortkey)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.get_invalid_account">
<code class="highlight language-python">
get_invalid_account
(self)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.get_invalid_account" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>See base class.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_invalid_account(self):
    """See base class."""
    return account.join(self.options['name_equity'], 'InvalidAccountName')
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.get_long_string_maxlines">
<code class="highlight language-python">
get_long_string_maxlines
(self)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.get_long_string_maxlines" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>See base class.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_long_string_maxlines(self):
    """See base class."""
    return self.options['long_string_maxlines']
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.get_options">
<code class="highlight language-python">
get_options
(self)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.get_options" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return the final options map.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A dict of option names to options.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_options(self):
    """Return the final options map.

    Returns:
      A dict of option names to options.
    """
    # Build and store the inferred DisplayContext instance.
    self.options['dcontext'] = self.dcontext

    # Add the full list of seen commodities.
    #
    # IMPORTANT: This is currently where the list of all commodities seen
    # from the parser lives. The
    # beancount.core.getters.get_commodities_map() routine uses this to
    # automatically generate a full list of directives. An alternative would
    # be to implement a plugin that enforces the generate of these
    # post-parsing so that they are always guaranteed to live within the
    # flow of entries. This would allow us to keep all the data in that list
    # of entries and to avoid depending on the options to store that output.
    self.options['commodities'] = self.commodities

    return self.options
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.handle_list">
<code class="highlight language-python">
handle_list
(self, object_list, new_object)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.handle_list" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Handle a recursive list grammar rule, generically.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>object_list</code></td>
<td><code></code></td>
<td>
<p>the current list of objects.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>new_object</code></td>
<td><code></code></td>
<td>
<p>the new object to be added.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new, updated list of objects.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def handle_list(self, object_list, new_object):
    """Handle a recursive list grammar rule, generically.

    Args:
      object_list: the current list of objects.
      new_object: the new object to be added.
    Returns:
      The new, updated list of objects.
    """
    if object_list is None:
        object_list = []
    if new_object is not None:
        object_list.append(new_object)
    return object_list
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.include">
<code class="highlight language-python">
include
(self, filename, lineno, include_filename)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.include" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an include directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>include_name</code></td>
<td><code></code></td>
<td>
<p>A string, the name of the file to include.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def include(self, filename, lineno, include_filename):
    """Process an include directive.

    Args:
      filename: current filename.
      lineno: current line number.
      include_name: A string, the name of the file to include.
    """
    self.options['include'].append(include_filename)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.key_value">
<code class="highlight language-python">
key_value
(self, key, value)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.key_value" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a document directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the account the document relates to.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>document_filename</code></td>
<td><code></code></td>
<td>
<p>A str, the name of the document file.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new KeyValue object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def key_value(self, key, value):
    """Process a document directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account the document relates to.
      document_filename: A str, the name of the document file.
    Returns:
      A new KeyValue object.
    """
    return KeyValue(key, value)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.note">
<code class="highlight language-python">
note
(self, filename, lineno, date, account, comment, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.note" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a note directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the account to attach the note to.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>comment</code></td>
<td><code></code></td>
<td>
<p>A str, the note's comments contents.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Note object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def note(self, filename, lineno, date, account, comment, kvlist):
    """Process a note directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to attach the note to.
      comment: A str, the note's comments contents.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Note object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Note(meta, date, account, comment)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.open">
<code class="highlight language-python">
open
(self, filename, lineno, date, account, currencies, booking_str, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.open" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an open directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the name of the account.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currencies</code></td>
<td><code></code></td>
<td>
<p>A list of constraint currencies.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>booking_str</code></td>
<td><code></code></td>
<td>
<p>A string, the booking method, or None if none was specified.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Open object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def open(self, filename, lineno, date, account, currencies, booking_str, kvlist):
    """Process an open directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the name of the account.
      currencies: A list of constraint currencies.
      booking_str: A string, the booking method, or None if none was specified.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Open object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    error = False
    if booking_str:
        try:
            # Note: Somehow the 'in' membership operator is not defined on Enum.
            booking = Booking[booking_str]
        except KeyError:
            # If the per-account method is invalid, set it to the global
            # default method and continue.
            booking = self.options['booking_method']
            error = True
    else:
        booking = None

    entry = Open(meta, date, account, currencies, booking)
    if error:
        self.errors.append(ParserError(meta,
                                       "Invalid booking method: {}".format(booking_str),
                                       entry))
    return entry
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.option">
<code class="highlight language-python">
option
(self, filename, lineno, key, value)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.option" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an option directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>key</code></td>
<td><code></code></td>
<td>
<p>option's key (str)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>option's value</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def option(self, filename, lineno, key, value):
    """Process an option directive.

    Args:
      filename: current filename.
      lineno: current line number.
      key: option's key (str)
      value: option's value
    """
    if key not in self.options:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Invalid option: '{}'".format(key), None))

    elif key in options.READ_ONLY_OPTIONS:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Option '{}' may not be set".format(key), None))

    else:
        option_descriptor = options.OPTIONS[key]

        # Issue a warning if the option is deprecated.
        if option_descriptor.deprecated:
            assert isinstance(option_descriptor.deprecated, str), "Internal error."
            meta = new_metadata(filename, lineno)
            self.errors.append(
                DeprecatedError(meta, option_descriptor.deprecated, None))

        # Rename the option if it has an alias.
        if option_descriptor.alias:
            key = option_descriptor.alias
            option_descriptor = options.OPTIONS[key]

        # Convert the value, if necessary.
        if option_descriptor.converter:
            try:
                value = option_descriptor.converter(value)
            except ValueError as exc:
                meta = new_metadata(filename, lineno)
                self.errors.append(
                    ParserError(meta,
                                "Error for option '{}': {}".format(key, exc),
                                None))
                return

        option = self.options[key]
        if isinstance(option, list):
            # Append to a list of values.
            option.append(value)

        elif isinstance(option, dict):
            # Set to a dict of values.
            if not (isinstance(value, tuple) and len(value) == 2):
                self.errors.append(
                    ParserError(
                        meta, "Error for option '{}': {}".format(key, value), None))
                return
            dict_key, dict_value = value
            option[dict_key] = dict_value

        elif isinstance(option, bool):
            # Convert to a boolean.
            if not isinstance(value, bool):
                value = (value.lower() in {'true', 'on'}) or (value == '1')
            self.options[key] = value

        else:
            # Set the value.
            self.options[key] = value

        # Refresh the list of valid account regexps as we go along.
        if key.startswith('name_'):
            # Update the set of valid account types.
            self.account_regexp = valid_account_regexp(self.options)
        elif key == 'insert_pythonpath':
            # Insert the PYTHONPATH to this file when and only if you
            # encounter this option.
            sys.path.insert(0, path.dirname(filename))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.pad">
<code class="highlight language-python">
pad
(self, filename, lineno, date, account, source_account, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.pad" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a pad directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>A datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the account to be padded.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>source_account</code></td>
<td><code></code></td>
<td>
<p>A string, the account to pad from.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Pad object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def pad(self, filename, lineno, date, account, source_account, kvlist):
    """Process a pad directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to be padded.
      source_account: A string, the account to pad from.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Pad object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Pad(meta, date, account, source_account)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.pipe_deprecated_error">
<code class="highlight language-python">
pipe_deprecated_error
(self, filename, lineno)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.pipe_deprecated_error" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Issue a 'Pipe deprecated' error.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>The current filename</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>The current line number</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def pipe_deprecated_error(self, filename, lineno):
    """Issue a 'Pipe deprecated' error.

    Args:
      filename: The current filename
      lineno: The current line number
    """
    if self.options['allow_pipe_separator']:
        return
    meta = new_metadata(filename, lineno)
    self.errors.append(
        ParserSyntaxError(meta, "Pipe symbol is deprecated.", None))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.plugin">
<code class="highlight language-python">
plugin
(self, filename, lineno, plugin_name, plugin_config)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.plugin" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a plugin directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>plugin_name</code></td>
<td><code></code></td>
<td>
<p>A string, the name of the plugin module to import.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>plugin_config</code></td>
<td><code></code></td>
<td>
<p>A string or None, an optional configuration string to
pass in to the plugin module.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def plugin(self, filename, lineno, plugin_name, plugin_config):
    """Process a plugin directive.

    Args:
      filename: current filename.
      lineno: current line number.
      plugin_name: A string, the name of the plugin module to import.
      plugin_config: A string or None, an optional configuration string to
        pass in to the plugin module.
    """
    self.options['plugin'].append((plugin_name, plugin_config))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.popmeta">
<code class="highlight language-python">
popmeta
(self, key)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.popmeta" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Removed a key off the current set of stacks.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td><code></code></td>
<td>
<p>A string, a key to be removed from the meta dict.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def popmeta(self, key):
    """Removed a key off the current set of stacks.

    Args:
      key: A string, a key to be removed from the meta dict.
    """
    try:
        if key not in self.meta:
            raise IndexError
        value_list = self.meta[key]
        value_list.pop(-1)
        if not value_list:
            self.meta.pop(key)
    except IndexError:
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta,
                        "Attempting to pop absent metadata key: '{}'".format(key),
                        None))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.poptag">
<code class="highlight language-python">
poptag
(self, tag)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.poptag" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Pop a tag off the current set of stacks.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td><code></code></td>
<td>
<p>A string, a tag to be removed from the current set of tags.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def poptag(self, tag):
    """Pop a tag off the current set of stacks.

    Args:
      tag: A string, a tag to be removed from the current set of tags.
    """
    try:
        self.tags.remove(tag)
    except ValueError:
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta, "Attempting to pop absent tag: '{}'".format(tag), None))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.posting">
<code class="highlight language-python">
posting
(self, filename, lineno, account, units, cost, price, istotal, flag)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.posting" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a posting grammar rule.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>account</code></td>
<td><code></code></td>
<td>
<p>A string, the account of the posting.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>units</code></td>
<td><code></code></td>
<td>
<p>An instance of Amount for the units.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cost</code></td>
<td><code></code></td>
<td>
<p>An instance of CostSpec for the cost.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>price</code></td>
<td><code></code></td>
<td>
<p>Either None, or an instance of Amount that is the cost of the position.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>istotal</code></td>
<td><code></code></td>
<td>
<p>A bool, True if the price is for the total amount being parsed, or
       False if the price is for each lot of the position.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>flag</code></td>
<td><code></code></td>
<td>
<p>A string, one-character, the flag associated with this posting.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Posting object, with no parent entry.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def posting(self, filename, lineno, account, units, cost, price, istotal, flag):
    """Process a posting grammar rule.

    Args:
      filename: the current filename.
      lineno: the current line number.
      account: A string, the account of the posting.
      units: An instance of Amount for the units.
      cost: An instance of CostSpec for the cost.
      price: Either None, or an instance of Amount that is the cost of the position.
      istotal: A bool, True if the price is for the total amount being parsed, or
               False if the price is for each lot of the position.
      flag: A string, one-character, the flag associated with this posting.
    Returns:
      A new Posting object, with no parent entry.
    """
    meta = new_metadata(filename, lineno)

    # Prices may not be negative.
    if price and isinstance(price.number, Decimal) and price.number &lt; ZERO:
        self.errors.append(
            ParserError(meta, (
                "Negative prices are not allowed: {} "
                "(see http://furius.ca/beancount/doc/bug-negative-prices "
                "for workaround)"
            ).format(price), None))
        # Fix it and continue.
        price = Amount(abs(price.number), price.currency)

    # If the price is specified for the entire amount, compute the effective
    # price here and forget about that detail of the input syntax.
    if istotal:
        if units.number == ZERO:
            number = ZERO
        else:
            number = price.number/abs(units.number)
        price = Amount(number, price.currency)

    # Note: Allow zero prices because we need them for round-trips for
    # conversion entries.
    #
    # if price is not None and price.number == ZERO:
    #     self.errors.append(
    #         ParserError(meta, "Price is zero: {}".format(price), None))

    # If both cost and price are specified, the currencies must match, or
    # that is an error.
    if (cost is not None and
        price is not None and
        isinstance(cost.currency, str) and
        isinstance(price.currency, str) and
        cost.currency != price.currency):
        self.errors.append(
            ParserError(meta,
                        "Cost and price currencies must match: {} != {}".format(
                            cost.currency, price.currency), None))

    return Posting(account, units, cost, price, chr(flag) if flag else None, meta)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.price">
<code class="highlight language-python">
price
(self, filename, lineno, date, currency, amount, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.price" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a price directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>currency</code></td>
<td><code></code></td>
<td>
<p>the currency to be priced.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>amount</code></td>
<td><code></code></td>
<td>
<p>an instance of Amount, that is the price of the currency.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Price object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def price(self, filename, lineno, date, currency, amount, kvlist):
    """Process a price directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      currency: the currency to be priced.
      amount: an instance of Amount, that is the price of the currency.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Price object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Price(meta, date, currency, amount)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.pushmeta">
<code class="highlight language-python">
pushmeta
(self, key, value)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.pushmeta" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Set a metadata field on the current key-value pairs to be added to transactions.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key_value</code></td>
<td><code></code></td>
<td>
<p>A KeyValue instance, to be added to the dict of metadata.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def pushmeta(self, key, value):
    """Set a metadata field on the current key-value pairs to be added to transactions.

    Args:
      key_value: A KeyValue instance, to be added to the dict of metadata.
    """
    self.meta[key].append(value)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.pushtag">
<code class="highlight language-python">
pushtag
(self, tag)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.pushtag" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Push a tag on the current set of tags.</p>
<p>Note that this does not need to be stack ordered.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td><code></code></td>
<td>
<p>A string, a tag to be added.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def pushtag(self, tag):
    """Push a tag on the current set of tags.

    Note that this does not need to be stack ordered.

    Args:
      tag: A string, a tag to be added.
    """
    self.tags.append(tag)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.query">
<code class="highlight language-python">
query
(self, filename, lineno, date, query_name, query_string, kvlist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.query" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a document directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>query_name</code></td>
<td><code></code></td>
<td>
<p>a str, the name of the query.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>query_string</code></td>
<td><code></code></td>
<td>
<p>a str, the SQL query itself.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kvlist</code></td>
<td><code></code></td>
<td>
<p>a list of KeyValue instances.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Query object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def query(self, filename, lineno, date, query_name, query_string, kvlist):
    """Process a document directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      query_name: a str, the name of the query.
      query_string: a str, the SQL query itself.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Query object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Query(meta, date, query_name, query_string)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.store_result">
<code class="highlight language-python">
store_result
(self, entries)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.store_result" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Start rule stores the final result here.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A list of entries to store.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def store_result(self, entries):
    """Start rule stores the final result here.

    Args:
      entries: A list of entries to store.
    """
    if entries:
        self.entries = entries
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.tag_link_LINK">
<code class="highlight language-python">
tag_link_LINK
(self, tags_links, link)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.tag_link_LINK" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Add a link to the TagsLinks accumulator.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tags_links</code></td>
<td><code></code></td>
<td>
<p>The current TagsLinks accumulator.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>link</code></td>
<td><code></code></td>
<td>
<p>A string, the new link to insert.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An updated TagsLinks instance.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def tag_link_LINK(self, tags_links, link):
    """Add a link to the TagsLinks accumulator.

    Args:
      tags_links: The current TagsLinks accumulator.
      link: A string, the new link to insert.
    Returns:
      An updated TagsLinks instance.
    """
    tags_links.links.add(link)
    return tags_links
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.tag_link_new">
<code class="highlight language-python">
tag_link_new
(self, _)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.tag_link_new" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create a new TagsLinks instance.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of TagsLinks, initialized with expected attributes.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def tag_link_new(self, _):
    """Create a new TagsLinks instance.

    Returns:
      An instance of TagsLinks, initialized with expected attributes.
    """
    return TagsLinks(set(), set())
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.tag_link_STRING">
<code class="highlight language-python">
tag_link_STRING
(self, tags_links, string)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.tag_link_STRING" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Add a string to the TagsLinks accumulator.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tags_links</code></td>
<td><code></code></td>
<td>
<p>The current TagsLinks accumulator.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code></code></td>
<td>
<p>A string, the new string to insert in the list.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An updated TagsLinks instance.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def tag_link_STRING(self, tags_links, string):
    """Add a string to the TagsLinks accumulator.

    Args:
      tags_links: The current TagsLinks accumulator.
      string: A string, the new string to insert in the list.
    Returns:
      An updated TagsLinks instance.
    """
    tags_links.strings.append(string)
    return tags_links
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.tag_link_TAG">
<code class="highlight language-python">
tag_link_TAG
(self, tags_links, tag)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.tag_link_TAG" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Add a tag to the TagsLinks accumulator.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tags_links</code></td>
<td><code></code></td>
<td>
<p>The current TagsLinks accumulator.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tag</code></td>
<td><code></code></td>
<td>
<p>A string, the new tag to insert.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An updated TagsLinks instance.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def tag_link_TAG(self, tags_links, tag):
    """Add a tag to the TagsLinks accumulator.

    Args:
      tags_links: The current TagsLinks accumulator.
      tag: A string, the new tag to insert.
    Returns:
      An updated TagsLinks instance.
    """
    tags_links.tags.add(tag)
    return tags_links
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.transaction">
<code class="highlight language-python">
transaction
(self, filename, lineno, date, flag, txn_strings, tags_links, posting_or_kv_list)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.transaction" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a transaction directive.</p>
<p>All the postings of the transaction are available at this point, and so the
the transaction is balanced here, incomplete postings are completed with the
appropriate position, and errors are being accumulated on the builder to be
reported later on.</p>
<p>This is the main routine that takes up most of the parsing time; be very
careful with modifications here, they have an impact on performance.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the current filename.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code></code></td>
<td>
<p>the current line number.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code></code></td>
<td>
<p>a datetime object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>flag</code></td>
<td><code></code></td>
<td>
<p>a str, one-character, the flag associated with this transaction.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>txn_strings</code></td>
<td><code></code></td>
<td>
<p>A list of strings, possibly empty, possibly longer.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tags_links</code></td>
<td><code></code></td>
<td>
<p>A TagsLinks namedtuple of tags, and/or links.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>posting_or_kv_list</code></td>
<td><code></code></td>
<td>
<p>a list of Posting or KeyValue instances, to be inserted in
this transaction, or None, if no postings have been declared.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new Transaction object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def transaction(self, filename, lineno, date, flag, txn_strings, tags_links,
                posting_or_kv_list):
    """Process a transaction directive.

    All the postings of the transaction are available at this point, and so the
    the transaction is balanced here, incomplete postings are completed with the
    appropriate position, and errors are being accumulated on the builder to be
    reported later on.

    This is the main routine that takes up most of the parsing time; be very
    careful with modifications here, they have an impact on performance.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      flag: a str, one-character, the flag associated with this transaction.
      txn_strings: A list of strings, possibly empty, possibly longer.
      tags_links: A TagsLinks namedtuple of tags, and/or links.
      posting_or_kv_list: a list of Posting or KeyValue instances, to be inserted in
        this transaction, or None, if no postings have been declared.
    Returns:
      A new Transaction object.
    """
    meta = new_metadata(filename, lineno)

    # Separate postings and key-values.
    explicit_meta = {}
    postings = []
    tags, links = tags_links.tags, tags_links.links
    if posting_or_kv_list:
        last_posting = None
        for posting_or_kv in posting_or_kv_list:
            if isinstance(posting_or_kv, Posting):
                postings.append(posting_or_kv)
                last_posting = posting_or_kv
            elif isinstance(posting_or_kv, TagsLinks):
                if postings:
                    self.errors.append(ParserError(
                        meta,
                        "Tags or links not allowed after first " +
                        "Posting: {}".format(posting_or_kv), None))
                else:
                    tags.update(posting_or_kv.tags)
                    links.update(posting_or_kv.links)
            else:
                if last_posting is None:
                    value = explicit_meta.setdefault(posting_or_kv.key,
                                                     posting_or_kv.value)
                    if value is not posting_or_kv.value:
                        self.errors.append(ParserError(
                            meta, "Duplicate metadata field on entry: {}".format(
                                posting_or_kv), None))
                else:
                    if last_posting.meta is None:
                        last_posting = last_posting._replace(meta={})
                        postings.pop(-1)
                        postings.append(last_posting)

                    value = last_posting.meta.setdefault(posting_or_kv.key,
                                                         posting_or_kv.value)
                    if value is not posting_or_kv.value:
                        self.errors.append(ParserError(
                            meta, "Duplicate posting metadata field: {}".format(
                                posting_or_kv), None))

    # Freeze the tags &amp; links or set to default empty values.
    tags, links = self.finalize_tags_links(tags, links)

    # Initialize the metadata fields from the set of active values.
    if self.meta:
        for key, value_list in self.meta.items():
            meta[key] = value_list[-1]

    # Add on explicitly defined values.
    if explicit_meta:
        meta.update(explicit_meta)

    # Unpack the transaction fields.
    payee_narration = self.unpack_txn_strings(txn_strings, meta)
    if payee_narration is None:
        return None
    payee, narration = payee_narration

    # We now allow a single posting when its balance is zero, so we
    # commented out the check below. If a transaction has a single posting
    # with a non-zero balance, it'll get caught below in the booking code.
    #
    # # Detect when a transaction does not have at least two legs.
    # if postings is None or len(postings) &lt; 2:
    #     self.errors.append(
    #         ParserError(meta,
    #                     "Transaction with only one posting: {}".format(postings),
    #                     None))
    #     return None

    # If there are no postings, make sure we insert a list object.
    if postings is None:
        postings = []

    # Create the transaction.
    return Transaction(meta, date, chr(flag),
                       payee, narration, tags, links, postings)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.Builder.unpack_txn_strings">
<code class="highlight language-python">
unpack_txn_strings
(self, txn_strings, meta)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.Builder.unpack_txn_strings" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Unpack a tags_links accumulator to its payee and narration fields.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>txn_strings</code></td>
<td><code></code></td>
<td>
<p>A list of strings.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>meta</code></td>
<td><code></code></td>
<td>
<p>A metadata dict for errors generated in this routine.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A pair of (payee, narration) strings or None objects, or None, if
there was an error.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def unpack_txn_strings(self, txn_strings, meta):
    """Unpack a tags_links accumulator to its payee and narration fields.

    Args:
      txn_strings: A list of strings.
      meta: A metadata dict for errors generated in this routine.
    Returns:
      A pair of (payee, narration) strings or None objects, or None, if
      there was an error.
    """
    num_strings = 0 if txn_strings is None else len(txn_strings)
    if num_strings == 1:
        payee, narration = None, txn_strings[0]
    elif num_strings == 2:
        payee, narration = txn_strings
    elif num_strings == 0:
        payee, narration = None, ""
    else:
        self.errors.append(
            ParserError(meta,
                        "Too many strings on transaction description: {}".format(
                            txn_strings), None))
        return None
    return payee, narration
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.CompoundAmount">
<code>CompoundAmount</code>
<a class="headerlink" href="#beancount.parser.grammar.CompoundAmount" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>CompoundAmount(number_per, number_total, currency)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.CompoundAmount.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.CompoundAmount.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.CompoundAmount.__new__">
<code class="highlight language-python">
__new__
(_cls, number_per, number_total, currency)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.CompoundAmount.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of CompoundAmount(number_per, number_total, currency)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.CompoundAmount.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.CompoundAmount.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.DeprecatedError">
<code>DeprecatedError</code>
<a class="headerlink" href="#beancount.parser.grammar.DeprecatedError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>DeprecatedError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.DeprecatedError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.DeprecatedError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.DeprecatedError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.DeprecatedError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of DeprecatedError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.DeprecatedError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.DeprecatedError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.KeyValue">
<code>KeyValue</code>
<a class="headerlink" href="#beancount.parser.grammar.KeyValue" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>KeyValue(key, value)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.KeyValue.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.KeyValue.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.KeyValue.__new__">
<code class="highlight language-python">
__new__
(_cls, key, value)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.KeyValue.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of KeyValue(key, value)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.KeyValue.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.KeyValue.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.ParserError">
<code>ParserError</code>
<a class="headerlink" href="#beancount.parser.grammar.ParserError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>ParserError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of ParserError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.ParserSyntaxError">
<code>ParserSyntaxError</code>
<a class="headerlink" href="#beancount.parser.grammar.ParserSyntaxError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>ParserSyntaxError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserSyntaxError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserSyntaxError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserSyntaxError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserSyntaxError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of ParserSyntaxError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ParserSyntaxError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ParserSyntaxError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.TagsLinks">
<code>TagsLinks</code>
<a class="headerlink" href="#beancount.parser.grammar.TagsLinks" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>TagsLinks(tags, links)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.TagsLinks.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.TagsLinks.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.TagsLinks.__new__">
<code class="highlight language-python">
__new__
(_cls, tags, links)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.TagsLinks.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of TagsLinks(tags, links)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.TagsLinks.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.TagsLinks.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar.ValueType">
<code>ValueType</code>
<a class="headerlink" href="#beancount.parser.grammar.ValueType" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>ValueType(value, dtype)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ValueType.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ValueType.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ValueType.__new__">
<code class="highlight language-python">
__new__
(_cls, value, dtype)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ValueType.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of ValueType(value, dtype)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar.ValueType.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar.ValueType.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.grammar.valid_account_regexp">
<code class="highlight language-python">
valid_account_regexp
(options)

        </code>
<a class="headerlink" href="#beancount.parser.grammar.valid_account_regexp" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Build a regexp to validate account names from the options.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>options</code></td>
<td><code></code></td>
<td>
<p>A dict of options, as per beancount.parser.options.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, a regular expression that will match all account names.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def valid_account_regexp(options):
    """Build a regexp to validate account names from the options.

    Args:
      options: A dict of options, as per beancount.parser.options.
    Returns:
      A string, a regular expression that will match all account names.
    """
    names = map(options.__getitem__, ('name_assets',
                                      'name_liabilities',
                                      'name_equity',
                                      'name_income',
                                      'name_expenses'))

    # Replace the first term of the account regular expression with the specific
    # names allowed under the options configuration. This code is kept in sync
    # with {5672c7270e1e}.
    return re.compile("(?:{})(?:{}{})+".format('|'.join(names),
                                               account.sep,
                                               account.ACC_COMP_NAME_RE))
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.grammar_test">
<code>grammar_test</code>
<a class="headerlink" href="#beancount.parser.grammar_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Tests for grammar parser.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestLexerAndParserErrors">
<code>TestLexerAndParserErrors</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestLexerAndParserErrors" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>There are a number of different paths where errors may occur. This test case
    intends to exercise them all. This docstring explains how it all works (it's
    a bit complicated).</p>
<pre><code>Expectations: The parser.parse_*() functions never raise exceptions, they
always produce a list of error messages on the builder objects. This is by
design: we have a single way to produce and report errors.

The lexer may fail in two different ways:

* Invalid Token: yylex() is invoked by the parser... the lexer rules are
  processed and all fail and the default rule of the lexer gets called at
  {bf253a29a820}. The lexer immediately switches to its INVALID subparser to
  chomp the rest of the invalid token's unrecognized characters until it
  hits some whitespace (see {bba169a1d35a}). A new LexerError is created and
  accumulated by calling the build_lexer_error() method on the builder
  object using this text (see {0e31aeca3363}). The lexer then returns a
  LEX_ERROR token to the parser, which fails as below.

* Lexer Builder Exception: The lexer recognizes a valid token and invokes a
  callback on the builder using BUILD_LEX(). However, an exception is raised
  in that Python code ({3cfb2739349a}). The exception's error text is saved
  and this is used to build an error on the lexer builder at
  build_lexer_error().

For both the errors above, when the parser receives the LEX_ERROR token, it
is an unexpected token (because none of the rules handle it), so it calls
yyerror() {ca6aab8b9748}. Because the lexer has already registered an error
in the error list, in yyerror() we simply ignore it and do nothing (see
{ca6aab8b9748}).

Error recovery then proceeds by successive reductions of the "error" grammar
rules which discards all tokens until a valid rule can be reduced again
({3d95e55b654e}). Note that Bison issues a single call to yyerror() and
keeps reducing invalid "error" rules silently until another one succeeds. We
ignore the directive and restart parsing from that point on. If the error
occurred on a posting in progress of being parsed, because the "error" rule
is not a valid posting of a transaction, that transaction will not be
produced and thus is ignore, which is what we want.

The parser may itself also encounter two similar types of errors:

* Syntax Error: There is an error in the grammar of the input. yyparse() is
  called automatically by the generated code and we call
  build_grammar_error() to register the error. Error recovery proceeds
  similarly to what was described previously.

* Grammar Builder Exception: A grammar rule is reduced successfully, a
  builder method is invoked and raises a Python exception. A macro in the
  code that invokes this method is used to catch this error and calls
  build_grammar_error_from_exception() to register an error and makes the
  parser issue an error wth YYERROR (see {05bb0fb60e86}).

We never call YYABORT anywhere so the yyparse() function should never return
anything else than 0. If it does, we translate that into a Python
RuntimeError exception, or a MemoryError exception (if yyparse() ran out of
memory), see {459018e2905c}.
</code></pre>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestLineNumbers">
<code>TestLineNumbers</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestLineNumbers" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Check that the line numbers line up correctly.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestMetaData">
<code>TestMetaData</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestMetaData" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.grammar_test.TestMetaData.strip_meta">
<code class="highlight language-python">
strip_meta
(meta)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.grammar_test.TestMetaData.strip_meta" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Removes the filename, lineno from the postings metadata.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">@staticmethod
def strip_meta(meta):
    """Removes the filename, lineno from the postings metadata."""
    copy = meta.copy()
    copy.pop('filename', None)
    copy.pop('lineno', None)
    return copy
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestParserComplete">
<code>TestParserComplete</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestParserComplete" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Tests of completion of balance.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestParserEntryTypes">
<code>TestParserEntryTypes</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestParserEntryTypes" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Basic smoke test one entry of each kind.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestSyntaxErrors">
<code>TestSyntaxErrors</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestSyntaxErrors" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Test syntax errors that occur within the parser.
    One of our goals is to recover and report without ever
    bailing out with an exception.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.TestUglyBugs">
<code>TestUglyBugs</code>
<a class="headerlink" href="#beancount.parser.grammar_test.TestUglyBugs" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Test all kinds of stupid sh*t that will inevitably occur in practice.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.check_list">
<code class="highlight language-python">
check_list
(test, objlist, explist)

        </code>
<a class="headerlink" href="#beancount.parser.grammar_test.check_list" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Assert the list of objects against the expected specification.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>test</code></td>
<td><code></code></td>
<td>
<p>the instance of the test object, used for generating assertions.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>objlist</code></td>
<td><code></code></td>
<td>
<p>the list of objects returned.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>explist</code></td>
<td><code></code></td>
<td>
<p>the list of objects expected. 'explist' can be an integer, to
       check the length of the list; if it is a list of types, the types
       are checked against the types of the objects in the list. This is
       meant to be a convenient method.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def check_list(test, objlist, explist):
    """Assert the list of objects against the expected specification.

    Args:
      test: the instance of the test object, used for generating assertions.
      objlist: the list of objects returned.

      explist: the list of objects expected. 'explist' can be an integer, to
               check the length of the list; if it is a list of types, the types
               are checked against the types of the objects in the list. This is
               meant to be a convenient method.
    """
    if isinstance(explist, int):
        test.assertEqual(explist, len(objlist))
    elif isinstance(explist, (tuple, list)):
        test.assertEqual(len(explist), len(objlist))
        for obj, exp in zip(objlist, explist):
            test.assertIsInstance(obj, exp)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.grammar_test.raise_exception">
<code class="highlight language-python">
raise_exception
    (*
args, **
kwargs)

        </code>
<a class="headerlink" href="#beancount.parser.grammar_test.raise_exception" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Raises a ValueError exception.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*args</code></td>
<td><code></code></td>
<td>
<p>Callback arguments.</p>
</td>
<td><code>()</code></td>
</tr>
<tr>
<td><code>*kwargs</code></td>
<td><code></code></td>
<td>
<p>Callback keyword arguments.</p>
</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>Unconditionally.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/grammar_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def raise_exception(*args, **kwargs):
    """Raises a ValueError exception.

    Args:
      *args: Callback arguments.
      *kwargs: Callback keyword arguments.
    Raises:
      ValueError: Unconditionally.
    """
    raise ValueError("Patched exception in parser")
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.hashsrc">
<code>hashsrc</code>
<a class="headerlink" href="#beancount.parser.hashsrc" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Compute a hash of the source files in order to warn when the source goes out of date.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.hashsrc.check_parser_source_files">
<code class="highlight language-python">
check_parser_source_files
()

        </code>
<a class="headerlink" href="#beancount.parser.hashsrc.check_parser_source_files" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Check the extension module's source hash and issue a warning if the
current source differs from that of the module.</p>
<p>If the source files aren't located in the Python source directory, ignore
the warning, we're probably running this from an installed based, in which
case we don't need to check anything (this check is useful only for people
running directly from source).</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/hashsrc.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def check_parser_source_files():
    """Check the extension module's source hash and issue a warning if the
    current source differs from that of the module.

    If the source files aren't located in the Python source directory, ignore
    the warning, we're probably running this from an installed based, in which
    case we don't need to check anything (this check is useful only for people
    running directly from source).
    """
    parser_source_hash = hash_parser_source_files()
    if parser_source_hash is None:
        return
    from . import _parser
    if _parser.SOURCE_HASH != parser_source_hash:
        warnings.warn("The Beancount parser C extension module is out-of-date. "
                      "You need to rebuild.")
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.hashsrc.hash_parser_source_files">
<code class="highlight language-python">
hash_parser_source_files
()

        </code>
<a class="headerlink" href="#beancount.parser.hashsrc.hash_parser_source_files" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Compute a unique hash of the parser's Python code in order to bake that into
the extension module. This is used at load-time to verify that the extension
module and the corresponding Python codes match each other. If not, it
issues a warning that you should rebuild your extension module.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the hexadecimal unique hash of relevant source code that should
trigger a recompilation.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/hashsrc.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def hash_parser_source_files():
    """Compute a unique hash of the parser's Python code in order to bake that into
    the extension module. This is used at load-time to verify that the extension
    module and the corresponding Python codes match each other. If not, it
    issues a warning that you should rebuild your extension module.

    Returns:
      A string, the hexadecimal unique hash of relevant source code that should
      trigger a recompilation.
    """
    md5 = hashlib.md5()
    for filename in PARSER_SOURCE_FILES:
        fullname = path.join(path.dirname(__file__), filename)
        if not path.exists(fullname):
            return None
        with open(fullname, 'rb') as file:
            md5.update(file.read())
    # Note: Prepend a character in front of the hash because under Windows MSDEV
    # removes escapes, and if the hash starts with a number it fails to
    # recognize this is a string. A small compromise for portability.
    return md5.hexdigest()
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.lexer">
<code>lexer</code>
<a class="headerlink" href="#beancount.parser.lexer" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Beancount syntax lexer.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder">
<code>LexBuilder</code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A builder used only for building lexer objects.</p>
<pre><code>Attributes:
  !!! long_string_maxlines_default "Number of lines for a string to trigger a"
      warning. This is meant to help users detecting dangling quotes in
      their source.
</code></pre>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.ACCOUNT">
<code class="highlight language-python">
ACCOUNT
(self, account_name)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.ACCOUNT" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an ACCOUNT token.</p>
<p>This function attempts to reuse an existing account if one exists,
otherwise creates one on-demand.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>account_name</code></td>
<td><code></code></td>
<td>
<p>a str, the valid name of an account.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the name of the account.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def ACCOUNT(self, account_name):
    """Process an ACCOUNT token.

    This function attempts to reuse an existing account if one exists,
    otherwise creates one on-demand.

    Args:
      account_name: a str, the valid name of an account.
    Returns:
      A string, the name of the account.
    """
    # Check account name validity.
    if not self.account_regexp.match(account_name):
        raise ValueError("Invalid account name: {}".format(account_name))

    # Reuse (intern) account strings as much as possible. This potentially
    # reduces memory usage a fair bit, because these strings are repeated
    # liberally.
    return self.accounts.setdefault(account_name, account_name)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.build_lexer_error">
<code class="highlight language-python">
build_lexer_error
(self, message, exc_type=None)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.build_lexer_error" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Build a lexer error and appends it to the list of pending errors.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td><code></code></td>
<td>
<p>The message of the error.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>exc_type</code></td>
<td><code></code></td>
<td>
<p>An exception type, if an exception occurred.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def build_lexer_error(self, message, exc_type=None): # {0e31aeca3363}
    """Build a lexer error and appends it to the list of pending errors.

    Args:
      message: The message of the error.
      exc_type: An exception type, if an exception occurred.
    """
    if not isinstance(message, str):
        message = str(message)
    if exc_type is not None:
        message = '{}: {}'.format(exc_type.__name__, message)
    self.errors.append(
        LexerError(self.get_lexer_location(), message, None))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.CURRENCY">
<code class="highlight language-python">
CURRENCY
(self, currency_name)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.CURRENCY" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a CURRENCY token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>currency_name</code></td>
<td><code></code></td>
<td>
<p>the name of the currency.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new currency object; for now, these are simply represented
as the currency name.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def CURRENCY(self, currency_name):
    """Process a CURRENCY token.

    Args:
      currency_name: the name of the currency.
    Returns:
      A new currency object; for now, these are simply represented
      as the currency name.
    """
    self.commodities.add(currency_name)
    return currency_name
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.DATE">
<code class="highlight language-python">
DATE
(self, year, month, day)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.DATE" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a DATE token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>year</code></td>
<td><code></code></td>
<td>
<p>integer year.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>month</code></td>
<td><code></code></td>
<td>
<p>integer month.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>day</code></td>
<td><code></code></td>
<td>
<p>integer day</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A new datetime object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def DATE(self, year, month, day):
    """Process a DATE token.

    Args:
      year: integer year.
      month: integer month.
      day: integer day
    Returns:
      A new datetime object.
    """
    return datetime.date(year, month, day)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.get_invalid_account">
<code class="highlight language-python">
get_invalid_account
(self)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.get_invalid_account" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return the name of an invalid account placeholder.</p>
<p>When an account name is not deemed a valid one, replace it by
this account name. This can be overridden by the parser to
take into account the options.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the name of the root/type for invalid account names.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_invalid_account(self):
    """Return the name of an invalid account placeholder.

    When an account name is not deemed a valid one, replace it by
    this account name. This can be overridden by the parser to
    take into account the options.

    Returns:
      A string, the name of the root/type for invalid account names.
    """
    return 'Equity:InvalidAccountName'
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.KEY">
<code class="highlight language-python">
KEY
(self, ident)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.KEY" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process an identifier token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ident</code></td>
<td><code></code></td>
<td>
<p>a str, the name of the key string.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The link string itself. For now we don't need to represent this by
an object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def KEY(self, ident):
    """Process an identifier token.

    Args:
      ident: a str, the name of the key string.
    Returns:
      The link string itself. For now we don't need to represent this by
      an object.
    """
    return ident
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.LINK">
<code class="highlight language-python">
LINK
(self, link)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.LINK" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a LINK token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>link</code></td>
<td><code></code></td>
<td>
<p>a str, the name of the string.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The link string itself. For now we don't need to represent this by
an object.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def LINK(self, link):
    """Process a LINK token.

    Args:
      link: a str, the name of the string.
    Returns:
      The link string itself. For now we don't need to represent this by
      an object.
    """
    return link
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.NUMBER">
<code class="highlight language-python">
NUMBER
(self, number)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.NUMBER" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a NUMBER token. Convert into Decimal.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>number</code></td>
<td><code></code></td>
<td>
<p>a str, the number to be converted.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A Decimal instance built of the number string.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def NUMBER(self, number):
    """Process a NUMBER token. Convert into Decimal.

    Args:
      number: a str, the number to be converted.
    Returns:
      A Decimal instance built of the number string.
    """
    # Note: We don't use D() for efficiency here.
    # The lexer will only yield valid number strings.
    if ',' in number:
        # Extract the integer part and check the commas match the
        # locale-aware formatted version. This
        match = re.match(r"([\d,]*)(\.\d*)?$", number)
        if not match:
            # This path is never taken because the lexer will parse a comma
            # in the fractional part as two NUMBERs with a COMMA token in
            # between.
            self.errors.append(
                LexerError(self.get_lexer_location(),
                           "Invalid number format: '{}'".format(number), None))
        else:
            int_string, float_string = match.groups()
            reformatted_number = r"{:,.0f}".format(int(int_string.replace(",", "")))
            if int_string != reformatted_number:
                self.errors.append(
                    LexerError(self.get_lexer_location(),
                               "Invalid commas: '{}'".format(number), None))

        number = number.replace(',', '')
    return Decimal(number)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.STRING">
<code class="highlight language-python">
STRING
(self, string)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.STRING" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a STRING token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string</code></td>
<td><code></code></td>
<td>
<p>the string to process.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The string. Nothing to be done or cleaned up. Eventually we might
do some decoding here.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def STRING(self, string):
    """Process a STRING token.

    Args:
      string: the string to process.
    Returns:
      The string. Nothing to be done or cleaned up. Eventually we might
      do some decoding here.
    """
    # If a multiline string, warm over a certain number of lines.
    if '\n' in string:
        num_lines = string.count('\n') + 1
        if num_lines &gt; self.long_string_maxlines_default:
            # This is just a warning; accept the string anyhow.
            self.errors.append(
                LexerError(
                    self.get_lexer_location(),
                    "String too long ({} lines); possible error".format(num_lines),
                    None))
    return string
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexBuilder.TAG">
<code class="highlight language-python">
TAG
(self, tag)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.LexBuilder.TAG" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Process a TAG token.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td><code></code></td>
<td>
<p>a str, the tag to be processed.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The tag string itself. For now we don't need an object to represent
those; keeping it simple.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def TAG(self, tag):
    """Process a TAG token.

    Args:
      tag: a str, the tag to be processed.
    Returns:
      The tag string itself. For now we don't need an object to represent
      those; keeping it simple.
    """
    return tag
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.lexer.LexerError">
<code>LexerError</code>
<a class="headerlink" href="#beancount.parser.lexer.LexerError" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>LexerError(source, message, entry)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexerError.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.lexer.LexerError.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexerError.__new__">
<code class="highlight language-python">
__new__
(_cls, source, message, entry)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.lexer.LexerError.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of LexerError(source, message, entry)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.lexer.LexerError.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.lexer.LexerError.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.lexer.lex_iter">
<code class="highlight language-python">
lex_iter
(file, builder=None, encoding=None)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.lex_iter" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>An iterator that yields all the tokens in the given file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file</code></td>
<td><code></code></td>
<td>
<p>A string, the filename to run the lexer on, or a file object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>builder</code></td>
<td><code></code></td>
<td>
<p>A builder of your choice. If not specified, a LexBuilder is
used and discarded (along with its errors).</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>encoding</code></td>
<td><code></code></td>
<td>
<p>A string (or None), the default encoding to use for strings.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p>Yields:
  Tuples of the token (a string), the matched text (a string), and the line
  no (an integer).</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def lex_iter(file, builder=None, encoding=None):
    """An iterator that yields all the tokens in the given file.

    Args:
      file: A string, the filename to run the lexer on, or a file object.
      builder: A builder of your choice. If not specified, a LexBuilder is
        used and discarded (along with its errors).
      encoding: A string (or None), the default encoding to use for strings.
    Yields:
      Tuples of the token (a string), the matched text (a string), and the line
      no (an integer).
    """
    if isinstance(file, str):
        filename = file
    else:
        filename = file.name
    if builder is None:
        builder = LexBuilder()
    _parser.lexer_initialize(filename, builder, encoding)
    try:
        while 1:
            token_tuple = _parser.lexer_next()
            if token_tuple is None:
                break
            yield token_tuple
    finally:
        _parser.lexer_finalize()
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.lexer.lex_iter_string">
<code class="highlight language-python">
lex_iter_string
(string, builder=None, encoding=None)

        </code>
<a class="headerlink" href="#beancount.parser.lexer.lex_iter_string" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Parse an input string and print the tokens to an output file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>input_string</code></td>
<td><code></code></td>
<td>
<p>a str or bytes, the contents of the ledger to be parsed.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>builder</code></td>
<td><code></code></td>
<td>
<p>A builder of your choice. If not specified, a LexBuilder is
used and discarded (along with its errors).</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>encoding</code></td>
<td><code></code></td>
<td>
<p>A string (or None), the default encoding to use for strings.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A iterator on the string. See lex_iter() for details.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def lex_iter_string(string, builder=None, encoding=None):
    """Parse an input string and print the tokens to an output file.

    Args:
      input_string: a str or bytes, the contents of the ledger to be parsed.
      builder: A builder of your choice. If not specified, a LexBuilder is
        used and discarded (along with its errors).
      encoding: A string (or None), the default encoding to use for strings.
    Returns:
      A iterator on the string. See lex_iter() for details.
    """
    tmp_file = tempfile.NamedTemporaryFile('w' if isinstance(string, str) else 'wb')
    tmp_file.write(string)
    tmp_file.flush()
    # Note: We pass in the file object in order to keep it alive during parsing.
    return lex_iter(tmp_file, builder, encoding)
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.lexer_test">
<code>lexer_test</code>
<a class="headerlink" href="#beancount.parser.lexer_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Tests for lexer.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.lexer_test.TestLexer">
<code>TestLexer</code>
<a class="headerlink" href="#beancount.parser.lexer_test.TestLexer" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Test output of the lexer.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.lexer_test.TestLexerErrors">
<code>TestLexerErrors</code>
<a class="headerlink" href="#beancount.parser.lexer_test.TestLexerErrors" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Test lexer error handling.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.lexer_test.lex_tokens">
<code class="highlight language-python">
lex_tokens
(fun)

        </code>
<a class="headerlink" href="#beancount.parser.lexer_test.lex_tokens" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Decorator for test functions that will invokve a lexer on them.</p>
<p>The lexer passes the list of tokens and errors to the test function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fun</code></td>
<td><code></code></td>
<td>
<p>A test function to be decorated.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The decorated function.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def lex_tokens(fun):
    """Decorator for test functions that will invokve a lexer on them.

    The lexer passes the list of tokens and errors to the test function.

    Args:
      fun: A test function to be decorated.
    Returns:
      The decorated function.
    """
    @functools.wraps(fun)
    def wrapped(self):
        string = fun.__doc__
        builder = lexer.LexBuilder()
        tokens = list(lexer.lex_iter_string(textwrap.dedent(string),
                                            builder))
        return fun(self, tokens, builder.errors)
    wrapped.__doc__ = None
    return wrapped
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.lexer_test.print_tokens">
<code class="highlight language-python">
print_tokens
(tokens)

        </code>
<a class="headerlink" href="#beancount.parser.lexer_test.print_tokens" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A function for printing a list of tokens, for testing.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tokens</code></td>
<td><code></code></td>
<td>
<p>A list of token tuples.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/lexer_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def print_tokens(tokens):
    """A function for printing a list of tokens, for testing.

    Args:
      tokens: A list of token tuples.
    """
    print()
    print(',--------------------------------')
    for token in tokens:
        print('{},'.format(token))
    print('`--------------------------------')
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.options">
<code>options</code>
<a class="headerlink" href="#beancount.parser.options" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Declaration of options and their default values.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.options.OptDesc">
<code>OptDesc</code>
<a class="headerlink" href="#beancount.parser.options.OptDesc" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>OptDesc(name, default_value, example_value, converter, deprecated, alias)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptDesc.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptDesc.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptDesc.__new__">
<code class="highlight language-python">
__new__
(_cls, name, default_value, example_value, converter, deprecated, alias)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptDesc.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of OptDesc(name, default_value, example_value, converter, deprecated, alias)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptDesc.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptDesc.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.options.OptGroup">
<code>OptGroup</code>
<a class="headerlink" href="#beancount.parser.options.OptGroup" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>OptGroup(description, options)</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptGroup.__getnewargs__">
<code class="highlight language-python">
__getnewargs__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptGroup.__getnewargs__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return self as a plain tuple.  Used by copy and pickle.</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptGroup.__new__">
<code class="highlight language-python">
__new__
(_cls, description, options)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
<small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptGroup.__new__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Create new instance of OptGroup(description, options)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.options.OptGroup.__repr__">
<code class="highlight language-python">
__repr__
(self)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.options.OptGroup.__repr__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Return a nicely formatted representation string</p>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.get_account_types">
<code class="highlight language-python">
get_account_types
(options)

        </code>
<a class="headerlink" href="#beancount.parser.options.get_account_types" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Extract the account type names from the parser's options.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>options</code></td>
<td><code></code></td>
<td>
<p>a dict of ledger options.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of AccountTypes, that contains all the prefixes.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_account_types(options):
    """Extract the account type names from the parser's options.

    Args:
      options: a dict of ledger options.
    Returns:
      An instance of AccountTypes, that contains all the prefixes.
    """
    return account_types.AccountTypes(
        *[options[key]
          for key in ("name_assets",
                      "name_liabilities",
                      "name_equity",
                      "name_income",
                      "name_expenses")])
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.get_current_accounts">
<code class="highlight language-python">
get_current_accounts
(options)

        </code>
<a class="headerlink" href="#beancount.parser.options.get_current_accounts" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return account names for the current earnings and conversion accounts.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>options</code></td>
<td><code></code></td>
<td>
<p>a dict of ledger options.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A tuple of 2 account objects, one for booking current earnings, and one
for current conversions.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_current_accounts(options):
    """Return account names for the current earnings and conversion accounts.

    Args:
      options: a dict of ledger options.
    Returns:
      A tuple of 2 account objects, one for booking current earnings, and one
      for current conversions.
    """
    equity = options['name_equity']
    account_current_earnings = account.join(equity,
                                            options['account_current_earnings'])
    account_current_conversions = account.join(equity,
                                               options['account_current_conversions'])
    return (account_current_earnings,
            account_current_conversions)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.get_previous_accounts">
<code class="highlight language-python">
get_previous_accounts
(options)

        </code>
<a class="headerlink" href="#beancount.parser.options.get_previous_accounts" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Return account names for the previous earnings, balances and conversion accounts.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>options</code></td>
<td><code></code></td>
<td>
<p>a dict of ledger options.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A tuple of 3 account objects, for booking previous earnings,
previous balances, and previous conversions.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def get_previous_accounts(options):
    """Return account names for the previous earnings, balances and conversion accounts.

    Args:
      options: a dict of ledger options.
    Returns:
      A tuple of 3 account objects, for booking previous earnings,
      previous balances, and previous conversions.
    """
    equity = options['name_equity']
    account_previous_earnings = account.join(equity,
                                             options['account_previous_earnings'])
    account_previous_balances = account.join(equity,
                                             options['account_previous_balances'])
    account_previous_conversions = account.join(equity,
                                                options['account_previous_conversions'])
    return (account_previous_earnings,
            account_previous_balances,
            account_previous_conversions)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.list_options">
<code class="highlight language-python">
list_options
()

        </code>
<a class="headerlink" href="#beancount.parser.options.list_options" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Produce a formatted text of the available options and their description.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, formatted nicely to be printed in 80 columns.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def list_options():
    """Produce a formatted text of the available options and their description.

    Returns:
      A string, formatted nicely to be printed in 80 columns.
    """
    oss = io.StringIO()
    for group in PUBLIC_OPTION_GROUPS:
        for desc in group.options:
            oss.write('option "{}" "{}"\n'.format(desc.name, desc.example_value))
            if desc.deprecated:
                oss.write(textwrap.fill(
                    "THIS OPTION IS DEPRECATED: {}".format(desc.deprecated),
                    initial_indent="  ",
                    subsequent_indent="  "))
                oss.write('\n\n')
        description = ' '.join(line.strip()
                               for line in group.description.strip().splitlines())
        oss.write(textwrap.fill(description,
                                initial_indent='  ',
                                subsequent_indent='  '))
        oss.write('\n')

        if isinstance(desc.default_value, (list, dict, set)):
            oss.write('\n')
            oss.write('  (This option may be supplied multiple times.)\n')

        oss.write('\n\n')

    return oss.getvalue()
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.Opt">
<code class="highlight language-python">
Opt
(name, default_value, example_value=&lt;object object at 0x7f44117cb940&gt;, converter=None, deprecated=False, alias=None)

        </code>
<a class="headerlink" href="#beancount.parser.options.Opt" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Alternative constructor for OptDesc, with default values.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>default_value</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>example_value</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><code>&lt;object object at 0x7f44117cb940&gt;</code></td>
</tr>
<tr>
<td><code>converter</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>deprecated</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>alias</code></td>
<td><code></code></td>
<td>
<p>See OptDesc.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An instance of OptDesc.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def Opt(name, default_value,
        example_value=UNSET,
        converter=None,
        deprecated=False,
        alias=None):
    """Alternative constructor for OptDesc, with default values.

    Args:
      name: See OptDesc.
      default_value: See OptDesc.
      example_value: See OptDesc.
      converter: See OptDesc.
      deprecated: See OptDesc.
      alias: See OptDesc.
    Returns:
      An instance of OptDesc.
    """
    if example_value is UNSET:
        example_value = default_value
    return OptDesc(name, default_value, example_value, converter, deprecated, alias)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_booking_method">
<code class="highlight language-python">
options_validate_booking_method
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_booking_method" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate a booking method name.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_booking_method(value):
    """Validate a booking method name.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    try:
        return data.Booking[value]
    except KeyError as exc:
        raise ValueError(str(exc))
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_boolean">
<code class="highlight language-python">
options_validate_boolean
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_boolean" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate a boolean option.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_boolean(value):
    """Validate a boolean option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    return value.lower() in ('1', 'true', 'yes')
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_plugin">
<code class="highlight language-python">
options_validate_plugin
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_plugin" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate the plugin option.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_plugin(value):
    """Validate the plugin option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    # Process the 'plugin' option specially: accept an optional
    # argument from it. NOTE: We will eventually phase this out and
    # replace it by a dedicated 'plugin' directive.
    match = re.match('(.*):(.*)', value)
    if match:
        plugin_name, plugin_config = match.groups()
    else:
        plugin_name, plugin_config = value, None
    return (plugin_name, plugin_config)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_processing_mode">
<code class="highlight language-python">
options_validate_processing_mode
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_processing_mode" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate the options processing mode.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_processing_mode(value):
    """Validate the options processing mode.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    if value not in ('raw', 'default'):
        raise ValueError("Invalid value '{}'".format(value))
    return value
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_tolerance">
<code class="highlight language-python">
options_validate_tolerance
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_tolerance" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate the tolerance option.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_tolerance(value):
    """Validate the tolerance option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    return D(value)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.options.options_validate_tolerance_map">
<code class="highlight language-python">
options_validate_tolerance_map
(value)

        </code>
<a class="headerlink" href="#beancount.parser.options.options_validate_tolerance_map" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Validate an option with a map of currency/tolerance pairs in a string.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>A string, the value provided as option.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>The new value, converted, if the conversion is successful.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValueError</code></td>
<td>
<p>If the value is invalid.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/options.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def options_validate_tolerance_map(value):
    """Validate an option with a map of currency/tolerance pairs in a string.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    # Process the setting of a key-value, whereby the value is a Decimal
    # representation.
    match = re.match('(.*):(.*)', value)
    if not match:
        raise ValueError("Invalid value '{}'".format(value))
    currency, tolerance_str = match.groups()
    return (currency, D(tolerance_str))
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.options_test">
<code>options_test</code>
<a class="headerlink" href="#beancount.parser.options_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Test various options.</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.parser">
<code>parser</code>
<a class="headerlink" href="#beancount.parser.parser" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Beancount syntax parser.</p>
<p>IMPORTANT: The parser (and its grammar builder) produces "incomplete"
Transaction objects. This means that some of the data can be found missing from
the output of the parser and some of the data types vary slightly. Missing
components are replaced not by None, but by a special constant 'NA' which helps
diagnose problems if a user inadvertently attempts to work on an incomplete
posting instead of a complete one. Those incomplete entries are then run through
the "booking" routines which do two things simultaneously:</p>
<ol>
<li>They find matching lots for reducing inventory positions, and</li>
<li>They interpolate missing numbers.</li>
</ol>
<p>In doing so they normalize the entries to "complete" entries by converting a
position/lot's "cost" attribute from a CostSpec to a Cost. A Cost is similar to
an Amount in that it shares "number" and "currency" attributes, but also has a
label and a lot date. A CostSpec is similar to a Cost, but has all optional
data; it consists in a specification for matching against a particular inventory
lot.</p>
<p>Other parts of a posting may also be missing, not just parts of the cost.
Leaving out some parts of the input is used to invoke interpolation, to tell
Beancount to automatically compute the missing numbers (if possible).</p>
<p>Missing components will be set to the special value
"beancount.core.number.MISSING" until inventory booking and number interpolation
has been completed. The "MISSING" value should never appear in completed, loaded
transaction postings.</p>
<p>For instance, all of the units may be missing:</p>
<p>INPUT: Assets:Account
  posting.units = MISSING</p>
<p>Or just the number of the units:</p>
<p>INPUT: Assets:Account                    USD
  posting.units = Amount(MISSING, "USD")</p>
<p>You must always specify the currency.</p>
<p>If a price annotation is simply absent, it appears as None:</p>
<p>INPUT: Assets:Account                 2 MXN
  posting.price = None</p>
<p>However, you may indicate that there is a price but have Beancount compute it
automatically:</p>
<p>INPUT: Assets:Account                 2 MXN @
  posting.price = Amount(MISSING, MISSING)</p>
<p>Indicating the conversion currency is also possible (and recommended):</p>
<p>INPUT: Assets:Account                 2 MXN @ USD
  posting.price = Amount(MISSING, "USD")</p>
<p>If a cost specification is provided, a "cost" attribute it set but it does not
refer to a Cost instance (as in complete entries) but rather to a CostSpec
instance. Some of the fields of a CostSpec may be MISSING if they were not
specified in the input. For exammple:</p>
<p>INPUT: Assets:Account  1 HOOL {100 # 5 USD}
  posting.cost = CostSpec(Decimal("100"), Decimal("5"), "USD", None, None, False))</p>
<p>Note how we never consider the label of date override to be MISSING; this is
because those inputs are optional: A missing label is simply left unset in the
computed Cost, and a missing date override uses the date of the transaction
that contains the posting.</p>
<p>You can indicate that there is a total number to be filled in like this:</p>
<p>INPUT: Assets:Account  1 HOOL {100 # USD}
  posting.cost = CostSpec(Decimal("100"), MISSING, "USD", None, None, False))</p>
<p>This is in contrast to the total value simple not being used:</p>
<p>INPUT: Assets:Account  1 HOOL {100 USD}
  posting.cost = CostSpec(Decimal("100"), None, "USD", None, None, False))</p>
<p>Both per-unit and total numbers may be omitted as well, in which case, only the
number-per-unit portion of the CostSpec will appear as MISSING:</p>
<p>INPUT: Assets:Account  1 HOOL {USD}
  posting.cost = CostSpec(MISSING, None, "USD", None, None, False))</p>
<p>And furthermore, all the cost basis may be missing:</p>
<p>INPUT: Assets:Account  1 HOOL {}
  posting.cost = CostSpec(MISSING, None, MISSING, None, None, False))</p>
<p>If you ask for the lots to be merged, you get this:</p>
<p>INPUT: Assets:Account  1 HOOL {*}
  posting.cost = CostSpec(MISSING, None, MISSING, None, None, True))</p>
<p>The numbers have to be computed by Beancount, so we output this with MISSING
values.</p>
<p>Of course, you can provide only the non-basis informations, like just the date
or label:</p>
<p>INPUT: Assets:Account  1 HOOL {2015-09-21}
  posting.cost = CostSpec(MISSING, None, MISSING, date(2015, 9, 21), None, True)</p>
<p>See the test beancount.parser.grammar_test.TestIncompleteInputs for examples and
corresponding expected values.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.is_entry_incomplete">
<code class="highlight language-python">
is_entry_incomplete
(entry)

        </code>
<a class="headerlink" href="#beancount.parser.parser.is_entry_incomplete" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Detect the presence of elided amounts in Transactions.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A directive.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A boolean, true if there are some missing portions of any postings found.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def is_entry_incomplete(entry):
    """Detect the presence of elided amounts in Transactions.

    Args:
      entries: A directive.
    Returns:
      A boolean, true if there are some missing portions of any postings found.
    """
    if isinstance(entry, data.Transaction):
        if any(is_posting_incomplete(posting) for posting in entry.postings):
            return True
    return False
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.is_posting_incomplete">
<code class="highlight language-python">
is_posting_incomplete
(posting)

        </code>
<a class="headerlink" href="#beancount.parser.parser.is_posting_incomplete" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Detect the presence of any elided amounts in a Posting.</p>
<p>If any of the possible amounts are missing, this returns True.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A directive.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A boolean, true if there are some missing portions of any postings found.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def is_posting_incomplete(posting):
    """Detect the presence of any elided amounts in a Posting.

    If any of the possible amounts are missing, this returns True.

    Args:
      entries: A directive.
    Returns:
      A boolean, true if there are some missing portions of any postings found.
    """
    units = posting.units
    if (units is MISSING or
        units.number is MISSING or
        units.currency is MISSING):
        return True
    price = posting.price
    if (price is MISSING or
        price is not None and (price.number is MISSING or
                               price.currency is MISSING)):
        return True
    cost = posting.cost
    if cost is not None and (cost.number_per is MISSING or
                             cost.number_total is MISSING or
                             cost.currency is MISSING):
        return True
    return False
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.parse_doc">
<code class="highlight language-python">
parse_doc
(expect_errors=False, allow_incomplete=False)

        </code>
<a class="headerlink" href="#beancount.parser.parser.parse_doc" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Factory of decorators that parse the function's docstring as an argument.</p>
<p>Note that the decorators thus generated only run the parser on the tests,
not the loader, so is no validation, balance checks, nor plugins applied to
the parsed text.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expect_errors</code></td>
<td><code></code></td>
<td>
<p>A boolean or None, with the following semantics,
True: Expect errors and fail if there are none.
False: Expect no errors and fail if there are some.
None: Do nothing, no check.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>allow_incomplete</code></td>
<td><code></code></td>
<td>
<p>A boolean, if true, allow incomplete input. Otherwise
barf if the input would require interpolation. The default value is set
not to allow it because we want to minimize the features tests depend on.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A decorator for test functions.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def parse_doc(expect_errors=False, allow_incomplete=False):
    """Factory of decorators that parse the function's docstring as an argument.

    Note that the decorators thus generated only run the parser on the tests,
    not the loader, so is no validation, balance checks, nor plugins applied to
    the parsed text.

    Args:
      expect_errors: A boolean or None, with the following semantics,
        True: Expect errors and fail if there are none.
        False: Expect no errors and fail if there are some.
        None: Do nothing, no check.
      allow_incomplete: A boolean, if true, allow incomplete input. Otherwise
        barf if the input would require interpolation. The default value is set
        not to allow it because we want to minimize the features tests depend on.
    Returns:
      A decorator for test functions.
    """
    def decorator(fun):
        """A decorator that parses the function's docstring as an argument.

        Args:
          fun: the function object to be decorated.
        Returns:
          A decorated test function.
        """
        filename = inspect.getfile(fun)
        lines, lineno = inspect.getsourcelines(fun)

        # decorator line + function definition line (I realize this is largely
        # imperfect, but it's only for reporting in our tests) - empty first line
        # stripped away.
        lineno += 1

        @functools.wraps(fun)
        def wrapper(self):
            assert fun.__doc__ is not None, (
                "You need to insert a docstring on {}".format(fun.__name__))
            entries, errors, options_map = parse_string(fun.__doc__,
                                                        report_filename=filename,
                                                        report_firstline=lineno,
                                                        dedent=True)

            if not allow_incomplete and any(is_entry_incomplete(entry)
                                            for entry in entries):
                self.fail("parse_doc() may not use interpolation.")

            if expect_errors is not None:
                if expect_errors is False and errors:
                    oss = io.StringIO()
                    printer.print_errors(errors, file=oss)
                    self.fail("Unexpected errors found:\n{}".format(oss.getvalue()))
                elif expect_errors is True and not errors:
                    self.fail("Expected errors, none found:")

            return fun(self, entries, errors, options_map)

        wrapper.__input__ = wrapper.__doc__
        wrapper.__doc__ = None
        return wrapper

    return decorator
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.parse_file">
<code class="highlight language-python">
parse_file
    (filename, **
kw)

        </code>
<a class="headerlink" href="#beancount.parser.parser.parse_file" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Parse a beancount input file and return Ledger with the list of
transactions and tree of accounts.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>the name of the file to be parsed.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>kw</code></td>
<td><code></code></td>
<td>
<p>a dict of keywords to be applied to the C parser.</p>
</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A tuple of (
  list of entries parsed in the file,
  list of errors that were encountered during parsing, and
  a dict of the option values that were parsed from the file.)</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def parse_file(filename, **kw):
    """Parse a beancount input file and return Ledger with the list of
    transactions and tree of accounts.

    Args:
      filename: the name of the file to be parsed.
      kw: a dict of keywords to be applied to the C parser.
    Returns:
      A tuple of (
        list of entries parsed in the file,
        list of errors that were encountered during parsing, and
        a dict of the option values that were parsed from the file.)
    """
    abs_filename = path.abspath(filename) if filename else None
    builder = grammar.Builder(abs_filename)
    _parser.parse_file(filename, builder, **kw)
    return builder.finalize()
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.parse_many">
<code class="highlight language-python">
parse_many
(string, level=0)

        </code>
<a class="headerlink" href="#beancount.parser.parser.parse_many" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Parse a string with a snippet of Beancount input and replace vars from caller.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string</code></td>
<td><code></code></td>
<td>
<p>A string with some Beancount input.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>level</code></td>
<td><code></code></td>
<td>
<p>The number of extra stacks to ignore.</p>
</td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of entries.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AssertionError</code></td>
<td>
<p>If there are any errors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def parse_many(string, level=0):
    """Parse a string with a snippet of Beancount input and replace vars from caller.

    Args:
      string: A string with some Beancount input.
      level: The number of extra stacks to ignore.
    Returns:
      A list of entries.
    Raises:
      AssertionError: If there are any errors.
    """
    # Get the locals in the stack for the callers and produce the final text.
    frame = inspect.stack()[level+1]
    varkwds = frame[0].f_locals
    input_string = textwrap.dedent(string.format(**varkwds))

    # Parse entries and check there are no errors.
    entries, errors, __ = parse_string(input_string)
    assert not errors

    return entries
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.parse_one">
<code class="highlight language-python">
parse_one
(string)

        </code>
<a class="headerlink" href="#beancount.parser.parser.parse_one" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Parse a string with single Beancount directive and replace vars from caller.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string</code></td>
<td><code></code></td>
<td>
<p>A string with some Beancount input.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>level</code></td>
<td><code></code></td>
<td>
<p>The number of extra stacks to ignore.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of entries.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AssertionError</code></td>
<td>
<p>If there are any errors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def parse_one(string):
    """Parse a string with single Beancount directive and replace vars from caller.

    Args:
      string: A string with some Beancount input.
      level: The number of extra stacks to ignore.
    Returns:
      A list of entries.
    Raises:
      AssertionError: If there are any errors.
    """
    entries = parse_many(string, level=1)
    assert len(entries) == 1
    return entries[0]
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.parser.parse_string">
<code class="highlight language-python">
parse_string
    (string, report_filename=None, **
kw)

        </code>
<a class="headerlink" href="#beancount.parser.parser.parse_string" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Parse a beancount input file and return Ledger with the list of
transactions and tree of accounts.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string</code></td>
<td><code></code></td>
<td>
<p>A string, the contents to be parsed instead of a file's.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>report_filename</code></td>
<td><code></code></td>
<td>
<p>A string, the source filename from which this string
has been extracted, if any. This is stored in the metadata of the
parsed entries.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>**kw</code></td>
<td><code></code></td>
<td>
<p>See parse.c. This function parses out 'dedent' which removes
whitespace from the front of the text (default is False).</p>
</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>Same as the output of parse_file().</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/parser.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def parse_string(string, report_filename=None, **kw):
    """Parse a beancount input file and return Ledger with the list of
    transactions and tree of accounts.

    Args:
      string: A string, the contents to be parsed instead of a file's.
      report_filename: A string, the source filename from which this string
        has been extracted, if any. This is stored in the metadata of the
        parsed entries.
      **kw: See parse.c. This function parses out 'dedent' which removes
        whitespace from the front of the text (default is False).
    Return:
      Same as the output of parse_file().
    """
    if kw.pop('dedent', None):
        string = textwrap.dedent(string)
    builder = grammar.Builder(report_filename or '&lt;string&gt;')
    _parser.parse_string(string, builder, report_filename=report_filename, **kw)
    return builder.finalize()
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.parser_test">
<code>parser_test</code>
<a class="headerlink" href="#beancount.parser.parser_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Tests for parser.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.parser_test.TestParserInputs">
<code>TestParserInputs</code>
<a class="headerlink" href="#beancount.parser.parser_test.TestParserInputs" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Try difference sources for the parser's input.</p>
<div class="doc doc-children">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.printer">
<code>printer</code>
<a class="headerlink" href="#beancount.parser.printer" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<p>Conversion from internal data structures to text.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h3 class="doc doc-heading" id="beancount.parser.printer.EntryPrinter">
<code>EntryPrinter</code>
<a class="headerlink" href="#beancount.parser.printer.EntryPrinter" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A multi-method interface for printing all directive types.</p>
<pre><code>Atributes:
  dcontext: An instance of DisplayContext with which to render all the numbers.
  render_weight: A boolean, true if we should render the weight of the postings
    as a comment, for debugging.
  min_width_account: An integer, the minimum width to leave for the account name.
</code></pre>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.printer.EntryPrinter.__call__">
<code class="highlight language-python">
__call__
(self, obj)

        </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#beancount.parser.printer.EntryPrinter.__call__" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Render a directive.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>obj</code></td>
<td><code></code></td>
<td>
<p>The directive to be rendered.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the rendered directive.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def __call__(self, obj):
    """Render a directive.

    Args:
      obj: The directive to be rendered.
    Returns:
      A string, the rendered directive.
    """
    oss = io.StringIO()
    method = getattr(self, obj.__class__.__name__)
    method(obj, oss)
    return oss.getvalue()
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.printer.EntryPrinter.render_posting_strings">
<code class="highlight language-python">
render_posting_strings
(self, posting)

        </code>
<a class="headerlink" href="#beancount.parser.printer.EntryPrinter.render_posting_strings" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>This renders the three components of a posting: the account and its optional
posting flag, the position, and finally, the weight of the position. The
purpose is to align these in the caller.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>posting</code></td>
<td><code></code></td>
<td>
<p>An instance of Posting, the posting to render.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A tuple of
  flag_account</code></td>
<td>
<p>A string, the account name including the flag.
  position_str: A string, the rendered position string.
  weight_str: A string, the rendered weight of the posting.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def render_posting_strings(self, posting):
    """This renders the three components of a posting: the account and its optional
    posting flag, the position, and finally, the weight of the position. The
    purpose is to align these in the caller.

    Args:
      posting: An instance of Posting, the posting to render.
    Returns:
      A tuple of
        flag_account: A string, the account name including the flag.
        position_str: A string, the rendered position string.
        weight_str: A string, the rendered weight of the posting.
    """
    # Render a string of the flag and the account.
    flag = '{} '.format(posting.flag) if posting.flag else ''
    flag_account = flag + posting.account

    # Render a string with the amount and cost and optional price, if
    # present. Also render a string with the weight.
    weight_str = ''
    if isinstance(posting.units, amount.Amount):
        position_str = position.to_string(posting, self.dformat)
        # Note: we render weights at maximum precision, for debugging.
        if posting.cost is None or (isinstance(posting.cost, position.Cost) and
                                    isinstance(posting.cost.number, Decimal)):
            weight_str = str(convert.get_weight(posting))
    else:
        position_str = ''

    if posting.price is not None:
        position_str += ' @ {}'.format(posting.price.to_string(self.dformat_max))

    return flag_account, position_str, weight_str
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h4 class="doc doc-heading" id="beancount.parser.printer.EntryPrinter.write_metadata">
<code class="highlight language-python">
write_metadata
(self, meta, oss, prefix='  ')

        </code>
<a class="headerlink" href="#beancount.parser.printer.EntryPrinter.write_metadata" title="Permanent link"></a></h4>
<div class="doc doc-contents">
<p>Write metadata to the file object, excluding filename and line number.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>meta</code></td>
<td><code></code></td>
<td>
<p>A dict that contains the metadata for this directive.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>oss</code></td>
<td><code></code></td>
<td>
<p>A file object to write to.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def write_metadata(self, meta, oss, prefix='  '):
    """Write metadata to the file object, excluding filename and line number.

    Args:
      meta: A dict that contains the metadata for this directive.
      oss: A file object to write to.
    """
    if meta is None:
        return
    for key, value in sorted(meta.items()):
        if key not in self.META_IGNORE:
            value_str = None
            if isinstance(value, str):
                value_str = '"{}"'.format(misc_utils.escape_string(value))
            elif isinstance(value, (Decimal, datetime.date, amount.Amount)):
                value_str = str(value)
            elif isinstance(value, bool):
                value_str = 'TRUE' if value else 'FALSE'
            elif isinstance(value, (dict, inventory.Inventory)):
                pass # Ignore dicts, don't print them out.
            elif value is None:
                value_str = ''  # Render null metadata as empty, on purpose.
            else:
                raise ValueError("Unexpected value: '{!r}'".format(value))
            if value_str is not None:
                oss.write("{}{}: {}\n".format(prefix, key, value_str))
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.align_position_strings">
<code class="highlight language-python">
align_position_strings
(strings)

        </code>
<a class="headerlink" href="#beancount.parser.printer.align_position_strings" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A helper used to align rendered amounts positions to their first currency
character (an uppercase letter). This class accepts a list of rendered
positions and calculates the necessary width to render them stacked in a
column so that the first currency word aligns. It does not go beyond that
(further currencies, e.g. for the price or cost, are not aligned).</p>
<p>This is perhaps best explained with an example. The following positions will
be aligned around the column marked with '^':</p>
<pre><code>      45 HOOL {504.30 USD}
       4 HOOL {504.30 USD, 2014-11-11}
    9.95 USD
</code></pre>
<p>-22473.32 CAD @ 1.10 USD
             ^</p>
<p>Strings without a currency character will be rendered flush left.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strings</code></td>
<td><code></code></td>
<td>
<p>A list of rendered position or amount strings.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A pair of a list of aligned strings and the width of the aligned strings.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def align_position_strings(strings):
    """A helper used to align rendered amounts positions to their first currency
    character (an uppercase letter). This class accepts a list of rendered
    positions and calculates the necessary width to render them stacked in a
    column so that the first currency word aligns. It does not go beyond that
    (further currencies, e.g. for the price or cost, are not aligned).

    This is perhaps best explained with an example. The following positions will
    be aligned around the column marked with '^':

              45 HOOL {504.30 USD}
               4 HOOL {504.30 USD, 2014-11-11}
            9.95 USD
       -22473.32 CAD @ 1.10 USD
                 ^

    Strings without a currency character will be rendered flush left.

    Args:
      strings: A list of rendered position or amount strings.
    Returns:
      A pair of a list of aligned strings and the width of the aligned strings.
    """
    # Maximum length before the alignment character.
    max_before = 0
    # Maximum length after the alignment character.
    max_after = 0
    # Maximum length of unknown strings.
    max_unknown = 0

    string_items = []
    search = re.compile('[A-Z]').search
    for string in strings:
        match = search(string)
        if match:
            index = match.start()
            if index != 0:
                max_before = max(index, max_before)
                max_after = max(len(string) - index, max_after)
                string_items.append((index, string))
                continue
        # else
        max_unknown = max(len(string), max_unknown)
        string_items.append((None, string))

    # Compute formatting string.
    max_total = max(max_before + max_after, max_unknown)
    max_after_prime = max_total - max_before
    fmt = "{{:&gt;{0}}}{{:{1}}}".format(max_before, max_after_prime).format
    fmt_unknown = "{{:&lt;{0}}}".format(max_total).format

    # Align the strings and return them.
    aligned_strings = []
    for index, string in string_items:
        if index is not None:
            string = fmt(string[:index], string[index:])
        else:
            string = fmt_unknown(string)
        aligned_strings.append(string)

    return aligned_strings, max_total
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.format_entry">
<code class="highlight language-python">
format_entry
(entry, dcontext=None, render_weights=False)

        </code>
<a class="headerlink" href="#beancount.parser.printer.format_entry" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Format an entry into a string in the same input syntax the parser accepts.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entry</code></td>
<td><code></code></td>
<td>
<p>An entry instance.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dcontext</code></td>
<td><code></code></td>
<td>
<p>An instance of DisplayContext used to format the numbers.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>render_weights</code></td>
<td><code></code></td>
<td>
<p>A boolean, true to render the weights for debugging.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the formatted entry.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def format_entry(entry, dcontext=None, render_weights=False):
    """Format an entry into a string in the same input syntax the parser accepts.

    Args:
      entry: An entry instance.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
    Returns:
      A string, the formatted entry.
    """
    return EntryPrinter(dcontext, render_weights)(entry)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.format_error">
<code class="highlight language-python">
format_error
(error)

        </code>
<a class="headerlink" href="#beancount.parser.printer.format_error" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Given an error objects, return a formatted string for it.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>error</code></td>
<td><code></code></td>
<td>
<p>a namedtuple objects representing an error. It has to have an
'entry' attribute that may be either a single directive object or a
list of directive objects.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, the errors rendered.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def format_error(error):
    """Given an error objects, return a formatted string for it.

    Args:
      error: a namedtuple objects representing an error. It has to have an
        'entry' attribute that may be either a single directive object or a
        list of directive objects.
    Returns:
      A string, the errors rendered.
    """
    oss = io.StringIO()
    oss.write('{} {}\n'.format(render_source(error.source), error.message))
    if error.entry is not None:
        entries = error.entry if isinstance(error.entry, list) else [error.entry]
        error_string = '\n'.join(format_entry(entry) for entry in entries)
        oss.write('\n')
        oss.write(textwrap.indent(error_string, '   '))
        oss.write('\n')
    return oss.getvalue()
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.print_entries">
<code class="highlight language-python">
print_entries
(entries, dcontext=None, render_weights=False, file=None, prefix=None)

        </code>
<a class="headerlink" href="#beancount.parser.printer.print_entries" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A convenience function that prints a list of entries to a file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entries</code></td>
<td><code></code></td>
<td>
<p>A list of directives.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dcontext</code></td>
<td><code></code></td>
<td>
<p>An instance of DisplayContext used to format the numbers.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>render_weights</code></td>
<td><code></code></td>
<td>
<p>A boolean, true to render the weights for debugging.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>file</code></td>
<td><code></code></td>
<td>
<p>An optional file object to write the entries to.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def print_entries(entries, dcontext=None, render_weights=False, file=None, prefix=None):
    """A convenience function that prints a list of entries to a file.

    Args:
      entries: A list of directives.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
      file: An optional file object to write the entries to.
    """
    assert isinstance(entries, list), "Entries is not a list: {}".format(entries)
    output = file or (codecs.getwriter("utf-8")(sys.stdout.buffer)
                      if hasattr(sys.stdout, 'buffer') else
                      sys.stdout)

    if prefix:
        output.write(prefix)
    previous_type = type(entries[0]) if entries else None
    eprinter = EntryPrinter(dcontext, render_weights)
    for entry in entries:
        # Insert a newline between transactions and between blocks of directives
        # of the same type.
        entry_type = type(entry)
        if (entry_type in (data.Transaction, data.Commodity) or
            entry_type is not previous_type):
            output.write('\n')
            previous_type = entry_type

        string = eprinter(entry)
        output.write(string)
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.print_entry">
<code class="highlight language-python">
print_entry
(entry, dcontext=None, render_weights=False, file=None)

        </code>
<a class="headerlink" href="#beancount.parser.printer.print_entry" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A convenience function that prints a single entry to a file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>entry</code></td>
<td><code></code></td>
<td>
<p>A directive entry.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dcontext</code></td>
<td><code></code></td>
<td>
<p>An instance of DisplayContext used to format the numbers.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>render_weights</code></td>
<td><code></code></td>
<td>
<p>A boolean, true to render the weights for debugging.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>file</code></td>
<td><code></code></td>
<td>
<p>An optional file object to write the entries to.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def print_entry(entry, dcontext=None, render_weights=False, file=None):
    """A convenience function that prints a single entry to a file.

    Args:
      entry: A directive entry.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
      file: An optional file object to write the entries to.
    """
    output = file or codecs.getwriter("utf-8")(sys.stdout.buffer)
    output.write(format_entry(entry, dcontext, render_weights))
    output.write('\n')
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.print_error">
<code class="highlight language-python">
print_error
(error, file=None)

        </code>
<a class="headerlink" href="#beancount.parser.printer.print_error" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A convenience function that prints a single error to a file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>error</code></td>
<td><code></code></td>
<td>
<p>An error object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>file</code></td>
<td><code></code></td>
<td>
<p>An optional file object to write the errors to.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def print_error(error, file=None):
    """A convenience function that prints a single error to a file.

    Args:
      error: An error object.
      file: An optional file object to write the errors to.
    """
    output = file or sys.stdout
    output.write(format_error(error))
    output.write('\n')
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.print_errors">
<code class="highlight language-python">
print_errors
(errors, file=None, prefix=None)

        </code>
<a class="headerlink" href="#beancount.parser.printer.print_errors" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>A convenience function that prints a list of errors to a file.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>errors</code></td>
<td><code></code></td>
<td>
<p>A list of errors.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>file</code></td>
<td><code></code></td>
<td>
<p>An optional file object to write the errors to.</p>
</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def print_errors(errors, file=None, prefix=None):
    """A convenience function that prints a list of errors to a file.

    Args:
      errors: A list of errors.
      file: An optional file object to write the errors to.
    """
    output = file or sys.stdout
    if prefix:
        output.write(prefix)
    for error in errors:
        output.write(format_error(error))
        output.write('\n')
</code></pre>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer.render_source">
<code class="highlight language-python">
render_source
(meta)

        </code>
<a class="headerlink" href="#beancount.parser.printer.render_source" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Render the source for errors in a way that it will be both detected by
Emacs and align and rendered nicely.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>meta</code></td>
<td><code></code></td>
<td>
<p>A dict with the metadata.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A string, rendered to be interpretable as a message location for Emacs or
other editors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def render_source(meta):
    """Render the source for errors in a way that it will be both detected by
    Emacs and align and rendered nicely.

    Args:
      meta: A dict with the metadata.
    Returns:
      A string, rendered to be interpretable as a message location for Emacs or
      other editors.
    """
    return '{}:{:8}'.format(meta['filename'], '{}:'.format(meta['lineno']))
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-module">
<h2 class="doc doc-heading" id="beancount.parser.printer_test">
<code>printer_test</code>
<a class="headerlink" href="#beancount.parser.printer_test" title="Permanent link"></a></h2>
<div class="doc doc-contents">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h3 class="doc doc-heading" id="beancount.parser.printer_test.characterize_spaces">
<code class="highlight language-python">
characterize_spaces
(text)

        </code>
<a class="headerlink" href="#beancount.parser.printer_test.characterize_spaces" title="Permanent link"></a></h3>
<div class="doc doc-contents">
<p>Classify each line to a particular type.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td><code></code></td>
<td>
<p>A string, the text to classify.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>A list of line types, one for each line.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>beancount/parser/printer_test.py</code></summary>
<pre class="highlight"><code class="language-python linenums">def characterize_spaces(text):
    """Classify each line to a particular type.

    Args:
      text: A string, the text to classify.
    Returns:
      A list of line types, one for each line.
    """
    lines = []
    for line in text.splitlines():
        if re.match(r'\d\d\d\d-\d\d-\d\d open', line):
            linecls = 'open'
        elif re.match(r'\d\d\d\d-\d\d-\d\d price', line):
            linecls = 'price'
        elif re.match(r'\d\d\d\d-\d\d-\d\d', line):
            linecls = 'txn'
        elif re.match(r'[ \t]$', line):
            linecls = 'empty'
        else:
            linecls = None
        lines.append(linecls)
    return lines
</code></pre>
</details>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-right" href="beancount.plugins.html" title="beancount.plugins">Next <span class="icon icon-circle-arrow-right"></span></a>
<a class="btn btn-neutral" href="beancount.ops.html" title="beancount.ops"><span class="icon icon-circle-arrow-left"></span> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<a class="fa fa-github" href="https://github.com/beancount/docs/" style="float: left; color: #fcfcfc"> GitHub</a>
<span><a href="beancount.ops.html" style="color: #fcfcfc;">« Previous</a></span>
<span style="margin-left: 15px"><a href="beancount.plugins.html" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script>var base_url = '..';</script>
<script defer="" src="../js/theme.js"></script>
<script defer="" src="../js/extra.js"></script>
<script defer="">
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>
</body>
</html>
